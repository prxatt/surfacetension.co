<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Surface Tension</title>
    <link rel="stylesheet" href="https://use.typekit.net/jhs3mli.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000000;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        .canvas-container, .overlay-container {
            position: fixed;
            width: 100%;
            height: 100%;
            transition: opacity 1.5s ease-in-out;
        }
        
        .canvas-container {
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }
        
        .canvas-container.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .overlay-container {
            z-index: 2;
            color: white;
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 0 5vw;
            opacity: 0;
            pointer-events: none;
        }
        .overlay-container.visible {
            opacity: 1;
            pointer-events: auto;
        }
        
        #start-overlay {
            position: fixed;
            inset: 0;
            z-index: 9999;
            background-color: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 1s ease-in-out;
            cursor: pointer;
        }
        #start-overlay.ready {
            opacity: 1;
            visibility: visible;
        }
        #start-prompt-container {
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 1rem 2rem;
            border-radius: 8px;
            background: rgba(10, 10, 10, 0.5);
            backdrop-filter: blur(5px);
            box-shadow: 0 0 25px rgba(255, 255, 255, 0.1);
            animation: pulse-glow 3s infinite;
        }
        #start-prompt {
            font-family: 'Inter', sans-serif;
            font-size: 1rem;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.8);
        }
        @keyframes pulse-glow {
            0% { box-shadow: 0 0 25px rgba(255, 255, 255, 0.1); }
            50% { box-shadow: 0 0 35px rgba(255, 255, 255, 0.2); }
            100% { box-shadow: 0 0 25px rgba(255, 255, 255, 0.1); }
        }

        #mute-button {
            position: fixed;
            top: 1.5rem;
            right: 1.5rem;
            z-index: 1001;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            opacity: 0;
            pointer-events: none;
        }
        #mute-button.visible {
            opacity: 0.5;
            pointer-events: auto;
        }
        #mute-button:hover {
            opacity: 1;
            transform: scale(1.1);
            background: rgba(255, 255, 255, 0.2);
        }
        #mute-button svg {
            width: 20px;
            height: 20px;
            color: white;
        }
        #unmuted-icon, #muted-icon {
            display: none;
        }
        #mute-button.unmuted #unmuted-icon { display: block; }
        #mute-button.muted #muted-icon { display: block; }

        #riddle-container {
            width: 100%;
            max-width: 650px; 
            position: relative;
            padding-bottom: 40px;
        }
        #riddle-text p {
            font-family: "ivypresto-display", serif;
            font-size: 1.1rem;
            font-weight: 400;
            line-height: 1.6;
            margin: 0.2em auto;
            color: rgba(255, 255, 255, 0.7);
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        #password-form {
            display: flex;
            align-items: center;
            width: 100%;
            max-width: 350px;
            margin: 2rem auto 0;
            position: relative;
        }
        #password-form.error {
            animation: shake 0.5s;
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }
        #password-input {
            background: transparent;
            border: none;
            outline: none;
            color: white;
            font-family: 'ivypresto-display', serif;
            font-size: 1.1rem;
            padding: 10px 15px;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            width: 100%;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            transition: border-color 0.3s;
        }
        #password-input:focus {
            border-color: rgba(255, 255, 255, 0.7);
        }
        #password-input::placeholder {
            color: rgba(255, 255, 255, 0.4);
            font-family: 'Inter', sans-serif;
            font-weight: 400;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            opacity: 0.5;
        }
        #submit-button { display: none; }
        
        #hint-container {
            position: absolute;
            bottom: 0;
            right: 0;
        }
        #hint-icon {
            width: 30px;
            height: 30px;
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            color: rgba(255,255,255,0.5);
        }
        #hint-icon:hover {
            background: rgba(255,255,255,0.1);
            color: white;
            transform: scale(1.1);
        }
        #hint-tooltip {
            position: absolute;
            bottom: 40px;
            right: 0;
            width: 250px;
            background: rgba(10, 10, 10, 0.9);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.2);
            padding: 1rem;
            border-radius: 8px;
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
            text-align: left;
            color: rgba(255,255,255,0.8);
            opacity: 0;
            visibility: hidden;
            transform: translateY(10px);
            transition: all 0.3s ease;
            pointer-events: none;
        }
        #hint-tooltip.visible {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        #animated-text-container {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 90%;
            max-width: 1000px;
            padding-bottom: 80px;
        }
        #event-date-container {
            display: flex;
            justify-content: space-between;
            width: 100%; 
            margin-bottom: 2rem;
            margin-top: -3.5rem;
        }
        .event-date-text {
            font-family: "ivypresto-display", serif;
            font-size: clamp(1.2rem, 2vw, 1.5rem);
            color: #10b981;
            background: linear-gradient(135deg, #10b981 0%, #059669 50%, #047857 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-transform: uppercase;
            font-weight: 500;
        }
        .event-date-text a {
            color: inherit;
            text-decoration: none;
            transition: filter 0.3s, text-shadow 0.3s;
        }
        .event-date-text a:hover {
            filter: brightness(1.3);
            text-shadow: 0 0 15px rgba(16, 185, 129, 0.6);
        }
        #animated-text {
            font-family: "ivypresto-display", serif;
            font-weight: 400;
            font-style: normal;
            font-size: clamp(2.5rem, 8vw, 6rem);
            line-height: 1.2;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: white;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.2), 0 0 30px rgba(255, 255, 255, 0.1);
            width: 100%; 
            word-wrap: break-word;
            hyphens: auto;
        }
        #subtext {
            font-family: 'Inter', sans-serif;
            font-weight: 500;
            font-size: clamp(1rem, 1.8vw, 1.3rem);
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 0.75rem; 
            opacity: 0;
            animation: fadeIn 1s ease 1s forwards;
        }
        @keyframes fadeIn { to { opacity: 1; } }
        #flicker-text {
            color: #10b981;
        }
        
        .subheading-rave {
            color: #a855f7;
            text-decoration: none;
            transition: color 0.3s ease, text-shadow 0.3s ease;
        }
        
        .subheading-rave:hover {
            color: #c084fc;
            text-shadow: 0 0 15px rgba(168, 85, 247, 0.6);
        }
        
        #neon-tickets-box {
            margin-top: 3rem;
            position: relative;
            display: inline-block;
            cursor: pointer;
            text-decoration: none;
            padding: 1rem 2rem;
            border: 2px solid #00ffff;
            border-radius: 8px;
            background: rgba(0, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            box-shadow: 
                0 0 20px rgba(0, 255, 255, 0.3),
                inset 0 0 20px rgba(0, 255, 255, 0.1);
        }
        
        #neon-tickets-box:hover {
            background: rgba(0, 255, 255, 0.15);
            box-shadow: 
                0 0 40px rgba(0, 255, 255, 0.6),
                0 0 80px rgba(0, 255, 255, 0.3),
                inset 0 0 30px rgba(0, 255, 255, 0.2);
            transform: translateY(-2px);
            border-color: #66ffff;
        }
        
        #neon-tickets-text {
            font-family: 'Inter', sans-serif;
            font-weight: 700;
            font-size: 1.2rem;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            color: #00ffff;
            text-shadow: 
                0 0 10px rgba(0, 255, 255, 0.8),
                0 0 20px rgba(0, 255, 255, 0.4);
            transition: all 0.3s ease;
        }
        
        #neon-tickets-box:hover #neon-tickets-text {
            color: #66ffff;
            text-shadow: 
                0 0 20px rgba(0, 255, 255, 1),
                0 0 40px rgba(0, 255, 255, 0.6),
                0 0 60px rgba(0, 255, 255, 0.3);
        }

        #access-code-wrapper {
            margin-top: 1.5rem;
            font-family: 'Inter', sans-serif;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.8rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
        }
        #access-code-text {
            color: rgba(255, 255, 255, 0.8);
            font-weight: 500;
            background-color: rgba(255, 255, 255, 0.05);
            padding: 0.3rem 0.6rem;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s, color 0.3s;
            animation: glitchLoop 2s infinite;
            display: inline-block;
        }
        #access-code-text:hover {
            background-color: rgba(255, 255, 255, 0.15);
            color: #fff;
            animation: none;
        }
        
        @keyframes glitchLoop {
            0%, 85%, 100% { 
                transform: translate(0);
                filter: hue-rotate(0deg);
                text-shadow: none;
            }
            87% { 
                transform: translate(-1px, 1px);
                filter: hue-rotate(90deg);
                text-shadow: 1px 0 #ff00ff, -1px 0 #00ffff;
            }
            89% { 
                transform: translate(1px, -1px);
                filter: hue-rotate(180deg);
                text-shadow: -1px 0 #ff00ff, 1px 0 #00ffff;
            }
            91% { 
                transform: translate(-1px, 0px);
                filter: hue-rotate(270deg);
                text-shadow: 1px 1px #ff00ff, -1px -1px #00ffff;
            }
        }

        #sextant-cube-container {
            margin-top: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            font-family: 'Inter', sans-serif;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.75rem;
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }
        
        #sextant-cube-canvas {
            width: 40px;
            height: 40px;
        }
        
        #sextant-link {
            color: rgba(255, 255, 255, 0.7);
            text-decoration: none;
            transition: color 0.3s ease, text-shadow 0.3s ease;
        }
        
        #sextant-link:hover {
            color: #fff;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
        #copy-notification {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #10b981;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.5s, transform 0.5s;
            pointer-events: none;
        }
        #copy-notification.show {
            opacity: 1;
            transform: translate(-50%, -10px);
        }

        #social-links-container {
            position: fixed;
            bottom: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1.75rem;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 1.5s ease-in-out;
        }
        #social-links-container.visible {
            opacity: 1;
            pointer-events: auto;
        }
        #social-links-container a {
            color: rgba(255, 255, 255, 0.5);
            transition: color 0.3s ease, transform 0.3s ease;
        }
        #social-links-container a:hover {
            color: #fff;
            transform: translateY(-2px);
        }
        #social-links-container svg {
            width: 22px;
            height: 22px;
        }
        
        /* Enhanced mobile responsive adjustments */
        @media (max-width: 768px) {
            #animated-text {
                font-size: clamp(2rem, 10vw, 4rem);
                line-height: 1.1;
                letter-spacing: 0.05em;
                text-align: center;
                padding: 0 1rem;
            }
            
            #animated-text-container {
                padding-bottom: 60px;
                width: 95%;
            }
            
            #event-date-container {
                flex-direction: column;
                gap: 0.25rem;
                text-align: center;
                margin-top: -2.5rem;
            }
            
            .event-date-text {
                font-size: clamp(0.9rem, 3vw, 1.2rem);
            }
            
            #subtext {
                font-size: clamp(0.8rem, 2.5vw, 1rem);
                text-align: center;
                padding: 0 1rem;
            }
            
            #neon-tickets-box {
                padding: 0.8rem 1.5rem;
                margin-top: 2rem;
            }
            
            #neon-tickets-text {
                font-size: 1rem;
                letter-spacing: 0.15em;
            }
        }
        
        @media (max-height: 500px) {
            #animated-text-container {
                padding-bottom: 60px;
            }
            #social-links-container {
                bottom: 1rem;
            }
        }

        @media (max-width: 480px) {
            #animated-text {
                font-size: clamp(1.8rem, 12vw, 3.5rem);
            }
            
            #riddle-text p {
                font-size: 1rem;
            }
            
            #password-input {
                font-size: 1rem;
            }
            
            #neon-tickets-text {
                font-size: 0.9rem;
            }
        }

    </style>
    <!-- Library Loading -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/MeshSurfaceSampler.js"></script>
</head>
<body>
    <div id="start-overlay">
        <div id="start-prompt-container">
            <div id="start-prompt">Initialize Sequence</div>
        </div>
    </div>

    <button id="mute-button" class="unmuted">
        <svg id="unmuted-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M19.114 5.636a9 9 0 010 12.728M16.463 8.288a5.25 5.25 0 010 7.424M6.75 8.25l4.72-4.72a.75.75 0 011.28.53v15.88a.75.75 0 01-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.01 9.01 0 012.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75z" /></svg>
        <svg id="muted-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M17.25 9.75L19.5 12m0 0l2.25 2.25M19.5 12l2.25-2.25M19.5 12l-2.25 2.25m-10.5-6l4.72-4.72a.75.75 0 011.28.53v15.88a.75.75 0 01-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.01 9.01 0 012.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75z" /></svg>
    </button>

    <div id="liminal-canvas-container" class="canvas-container">
        <canvas id="liminal-canvas"></canvas>
    </div>
    
    <div id="particle-canvas-container" class="canvas-container hidden">
        <canvas id="particle-canvas"></canvas>
    </div>
    
    <div id="riddle-overlay" class="overlay-container">
        <div id="riddle-container">
            <div id="riddle-text">
                <p>I am the space between one world and the next,</p>
                <p>a threshold of change where realities connect.</p>
                <p>What am I?</p>
            </div>
            <form id="password-form">
                <input type="password" id="password-input" placeholder="What am I?">
                <button type="submit" id="submit-button">&rarr;</button>
            </form>
            <div id="hint-container">
                <div id="hint-tooltip">The threshold exists where coffee meets consciousness—seek wisdom from the keepers of any Sextant Coffee sanctuary, or let the digital oracle reveal what lies between worlds.</div>
                <div id="hint-icon">?</div>
            </div>
        </div>
    </div>

    <div id="animated-text-container" class="overlay-container">
        <div id="event-date-container">
            <span class="event-date-text" id="event-date-left"></span>
            <span class="event-date-text" id="event-date-right"></span>
        </div>
        <h1 id="animated-text"></h1>
        <p id="subtext"><span id="flicker-text">Digital Drip</span> : <a href="https://www.eventbrite.com/e/surface-tension-digital-drip-an-after-hours-art-rave-tickets-1471279469499?utm-campaign=social&utm-content=attendeeshare&utm-medium=discovery&utm-term=listing&utm-source=cp&aff=ebdsshcopyurl" target="_blank" rel="noopener noreferrer" class="subheading-rave">An After-Hours Art Rave</a></p>
        
        <a id="neon-tickets-box" href="https://www.eventbrite.com/e/surface-tension-digital-drip-an-after-hours-art-rave-tickets-1471279469499?utm-campaign=social&utm-content=attendeeshare&utm-medium=discovery&utm-term=listing&utm-source=cp&aff=ebdsshcopyurl" target="_blank" rel="noopener noreferrer" aria-label="Purchase Tickets">
            <div id="neon-tickets-text">TICKETS</div>
        </a>

        <div id="access-code-wrapper">
            ACCESS CODE: <span id="access-code-text" onclick="handleAccessCode(event)">TENSION POINT</span>
        </div>
        
        <div id="sextant-cube-container">
            <canvas id="sextant-cube-canvas"></canvas>
            <a href="https://www.google.com/maps/place/539+Valencia+St,+San+Francisco,+CA+94110/@37.7625,-122.421,17z" target="_blank" rel="noopener noreferrer" id="sextant-link">Sextant Coffee Roasters</a>
        </div>
    </div>

    <div id="social-links-container">
        <a href="https://www.instagram.com/surfacetension.co" target="_blank" rel="noopener noreferrer" aria-label="Instagram">
            <svg fill="currentColor" viewBox="0 0 24 24"><path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.85s-.011 3.584-.069 4.85c-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07s-3.584-.012-4.85-.07c-3.252-.148-4.771-1.691-4.919-4.919-.058-1.265-.07-1.645-.07-4.85s.012-3.584.07-4.85c.148-3.225 1.664-4.771 4.919-4.919C8.416 2.175 8.796 2.163 12 2.163zm0 1.802c-3.143 0-3.505.012-4.73.068-2.693.123-3.995 1.424-4.118 4.118-.056 1.225-.068 1.586-.068 4.73s.012 3.505.068 4.73c.123 2.693 1.424 3.995 4.118 4.118 1.225.056 1.586.068 4.73.068s3.505-.012 4.73-.068c2.693-.123 3.995-1.424 4.118-4.118.056-1.225.068-1.586.068-4.73s-.012-3.505-.068-4.73c-.123-2.693-1.424-3.995-4.118-4.118-1.225-.056-1.586-.068-4.73-.068zm0 3.888c-2.402 0-4.35 1.948-4.35 4.35s1.948 4.35 4.35 4.35 4.35-1.948 4.35-4.35-1.948-4.35-4.35-4.35zm0 7.167c-1.553 0-2.817-1.264-2.817-2.817s1.264-2.817 2.817-2.817 2.817 1.264 2.817 2.817-1.264 2.817-2.817 2.817zm4.965-7.332c-.608 0-1.1.492-1.1 1.1s.492 1.1 1.1 1.1 1.1-.492 1.1-1.1-.492-1.1-1.1-1.1z"></path></svg>
        </a>
        <a href="https://www.twitter.com/surfacetensi_n" target="_blank" rel="noopener noreferrer" aria-label="Twitter">
            <svg fill="currentColor" viewBox="0 0 24 24"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"></path></svg>
        </a>
        <a href="https://www.tiktok.com/@surfacetension.co" target="_blank" rel="noopener noreferrer" aria-label="TikTok">
            <svg fill="currentColor" viewBox="0 0 24 24"><path d="M12.525.02c1.31-.02 2.61-.01 3.91-.02.08 1.53.63 3.09 1.75 4.17 1.12 1.11 2.7 1.62 4.24 1.79v4.03c-1.44-.05-2.89-.35-4.2-.97-.57-.26-1.1-.59-1.62-.93-.01 2.92.01 5.84-.02 8.75-.08 1.4-.54 2.79-1.35 3.94-1.31 1.92-3.58 3.17-5.91 3.21-2.43.05-4.84-.95-6.43-2.8-1.59-1.87-2.16-4.2-1.8-6.51.41-2.5 2.5-4.61 4.82-5.59.98-.4 2.02-.63 3.04-.77.02-2.88-.01-5.76.01-8.63.01-1.49.52-2.96 1.4-4.16.83-1.11 2.02-1.86 3.31-2.2z"></path></svg>
        </a>
        <a href="https://www.facebook.com/profile.php?id=61577915426183" target="_blank" rel="noopener noreferrer" aria-label="Facebook">
            <svg fill="currentColor" viewBox="0 0 24 24"><path d="M14 13.5h2.5l1-4H14v-2c0-1.03 0-2 2-2h1.5V2.14c-.326-.043-1.557-.14-2.857-.14C11.928 2 10 3.657 10 6.7v2.8H7v4h3v9h4z"></path></svg>
        </a>
    </div>

    <div id="copy-notification">Code Copied to Clipboard!</div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // -- Configuration --
        const TITLE_TEXT = "SURFACE TENSION";
        const CORRECT_PASSWORDS = ['LIMINAL', 'LIMINAL SPACE'];

        // -- Global State --
        const clock = new THREE.Clock();
        let activeScene = 'title';
        let isTransitioning = false;
        
        // -- Enhanced Performance Monitoring --
        let performanceStats = {
            frameRate: 60,
            qualityLevel: 'high',
            frameCount: 0,
            lastTime: performance.now(),
            consecutiveLowFrames: 0
        };
        
        // -- Scene Variables --
        let scene, camera, renderer, particles, composer, bloomPass;
        let particleScene, particleCamera, particleRenderer, particleComposer, backgroundVisual;
        let sextantCubeScene, sextantCubeCamera, sextantCubeRenderer, sextantCube;
        
        // -- Audio variables with mobile optimization --
        let audioInitialized = false;
        let audioContext = null;
        let droneSynth, arp, padSynth, disintegrateNoise, climaxChime, masterReverb, masterChorus, padFilter, cinematicLead;
        let silentAudioBuffer = null;

        let visualFeedback = { disperse: 0, glow: 0 };

        // -- Bypass State --
        const keysPressed = new Set();
        let tapCount = 0;
        let tapTimer = null;

        // -- OPTIMIZATION: Debounce function for resize handler
        function debounce(func, wait, immediate) {
            let timeout;
            return function() {
                const context = this, args = arguments;
                const later = function() {
                    timeout = null;
                    if (!immediate) func.apply(context, args);
                };
                const callNow = immediate && !timeout;
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
                if (callNow) func.apply(context, args);
            };
        };

        // -- ENHANCED: Mobile device detection with audio capabilities
        function getDeviceCapabilities() {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            
            const capabilities = {
                maxTextureSize: gl ? gl.getParameter(gl.MAX_TEXTURE_SIZE) : 1024,
                devicePixelRatio: window.devicePixelRatio,
                screenWidth: window.innerWidth,
                screenHeight: window.innerHeight,
                isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
                isIOS: /iPhone|iPad|iPod/i.test(navigator.userAgent),
                isAndroid: /Android/i.test(navigator.userAgent),
                memoryInfo: navigator.deviceMemory || 4,
                hasAudioContext: !!(window.AudioContext || window.webkitAudioContext),
                isLowEnd: false
            };
            
            // Enhanced low-end device detection
            capabilities.isLowEnd = capabilities.isMobile || 
                                   capabilities.screenWidth < 768 || 
                                   capabilities.devicePixelRatio < 1.5 ||
                                   capabilities.maxTextureSize < 2048 ||
                                   capabilities.memoryInfo < 4;
            
            return capabilities;
        }

        const DEVICE_CAPABILITIES = getDeviceCapabilities();

        // -- OPTIMIZATION: Device-adaptive settings with corrected mobile text scale
        function getOptimalSettings() {
            const capabilities = DEVICE_CAPABILITIES;
            
            if (capabilities.isLowEnd) {
                return {
                    particleCount: 20000,
                    backgroundParticleCount: 30000,
                    cubeParticleCount: 2000,
                    bloomStrength: 0.2,
                    pixelRatio: Math.min(capabilities.devicePixelRatio, 1.2),
                    qualityLevel: 'low'
                };
            } else if (capabilities.isMobile) {
                return {
                    particleCount: 60000,
                    backgroundParticleCount: 50000,
                    cubeParticleCount: 4000,
                    bloomStrength: 0.4,
                    pixelRatio: Math.min(capabilities.devicePixelRatio, 1.8),
                    qualityLevel: 'medium'
                };
            } else {
                return {
                    particleCount: 120000,
                    backgroundParticleCount: 70000,
                    cubeParticleCount: 6000,
                    bloomStrength: 0.6,
                    pixelRatio: Math.min(capabilities.devicePixelRatio, 2),
                    qualityLevel: 'high'
                };
            }
        }

        const OPTIMAL_SETTINGS = getOptimalSettings();
        const PARTICLE_COUNT = OPTIMAL_SETTINGS.particleCount;
        const FIELD_RADIUS = 100;

        // -- OPTIMIZATION: Enhanced frame rate monitoring with adaptive degradation
        function updatePerformanceStats() {
            performanceStats.frameCount++;
            const now = performance.now();
            
            if (now - performanceStats.lastTime >= 1000) {
                performanceStats.frameRate = performanceStats.frameCount;
                performanceStats.frameCount = 0;
                performanceStats.lastTime = now;
                
                // Track consecutive low frame periods
                if (performanceStats.frameRate < 30) {
                    performanceStats.consecutiveLowFrames++;
                } else {
                    performanceStats.consecutiveLowFrames = 0;
                }
                
                // Aggressive quality adjustment for sustained poor performance
                if (performanceStats.consecutiveLowFrames >= 2 && performanceStats.qualityLevel !== 'low') {
                    adjustQuality('low');
                } else if (performanceStats.frameRate < 45 && performanceStats.qualityLevel === 'high') {
                    adjustQuality('medium');
                }
            }
        }

        function adjustQuality(level) {
            performanceStats.qualityLevel = level;
            
            if (bloomPass) {
                switch(level) {
                    case 'low':
                        bloomPass.strength = 0.2;
                        bloomPass.threshold = 0.95;
                        bloomPass.radius = 0.3;
                        break;
                    case 'medium':
                        bloomPass.strength = 0.4;
                        bloomPass.threshold = 0.85;
                        bloomPass.radius = 0.5;
                        break;
                    case 'high':
                        bloomPass.strength = 0.6;
                        bloomPass.threshold = 0.8;
                        bloomPass.radius = 0.7;
                        break;
                }
            }
        }

        /*
         * ==================================
         * == OPTIMIZED SHADER CODE (GLSL) ==
         * ==================================
         */
        const particleVertexShader = `
            uniform float uTime;
            uniform float uExpansionProgress;
            uniform float uConvergenceProgress;
            uniform float uDisintegrationProgress;
            uniform float uFieldRadius;
            uniform float uDisperse;

            attribute float aSize;
            attribute vec3 aColor;
            attribute vec3 aTargetPosition;
            attribute float aRandomness;
            attribute float aIsTextParticle;
            attribute vec3 aTextTargetPosition;

            varying vec3 vColor;
            varying float vAlpha;

            // Optimized noise function
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            float snoise(vec3 v) {
                const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i  = floor(v + dot(v, C.yyy));
                vec3 x0 = v - i + dot(i, C.xxx);
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min(g.xyz, l.zxy);
                vec3 i2 = max(g.xyz, l.zxy);
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;
                i = mod289(i);
                vec4 p = permute(permute(permute(
                            i.z + vec4(0.0, i1.z, i2.z, 1.0))
                        + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                        + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                float n_ = 0.142857142857;
                vec3 ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_);
                vec4 x = x_ * ns.x + ns.yyyy;
                vec4 y = y_ * ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4(x.xy, y.xy);
                vec4 b1 = vec4(x.zw, y.zw);
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
                vec3 p0 = vec3(a0.xy,h.x);
                vec3 p1 = vec3(a0.zw,h.y);
                vec3 p2 = vec3(a1.xy,h.z);
                vec3 p3 = vec3(a1.zw,h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
            }
            
            void main() {
                vec3 chaoticPos = aTargetPosition;
                float noiseFactor = snoise(vec3(chaoticPos.xy * 0.05, uTime * 0.1 + aRandomness * 5.0));
                chaoticPos.z += noiseFactor * 2.0;
                chaoticPos.x += snoise(vec3(chaoticPos.yz * 0.05, uTime * 0.1)) * 0.5;
                chaoticPos.y += snoise(vec3(chaoticPos.xz * 0.05, uTime * 0.1)) * 0.5;
                float speed = uTime * 2.0;
                vec3 drift = vec3(0.0);
                if (length(aTargetPosition) > 0.0) {
                    drift = normalize(aTargetPosition) * speed;
                }
                float fieldDiameter = uFieldRadius * 2.0;
                chaoticPos = mod(chaoticPos + drift + uFieldRadius, fieldDiameter) - uFieldRadius;
                vec3 pos = mix(vec3(0.0), chaoticPos, uExpansionProgress);
                
                float convergenceFactor = smoothstep(0.0, 1.0, uConvergenceProgress);
                float disintegrationFactor = smoothstep(0.0, 1.0, uDisintegrationProgress);

                if (aIsTextParticle > 0.5) {
                    vec3 convergedPos = mix(pos, aTextTargetPosition, convergenceFactor);
                    pos = mix(convergedPos, chaoticPos, disintegrationFactor);
                }
                
                pos.x += snoise(vec3(pos.y * 0.5, uTime * 2.0, aRandomness)) * uDisperse;
                pos.y += snoise(vec3(pos.z * 0.5, uTime * 2.0, aRandomness)) * uDisperse;
                
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_PointSize = aSize * (200.0 / -mvPosition.z);
                float depth = -mvPosition.z;
                vAlpha = smoothstep(uFieldRadius * 1.5, uFieldRadius * 0.5, depth); 
                vAlpha *= uExpansionProgress;
                
                if (aIsTextParticle > 0.5) {
                    float textVisibility = convergenceFactor * (1.0 - disintegrationFactor);
                    vAlpha = mix(vAlpha, 0.9, textVisibility);
                    vColor = mix(aColor, vec3(1.5, 1.5, 1.5), textVisibility);
                } else {
                    vColor = aColor;
                }
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const particleFragmentShader = `
            varying vec3 vColor;
            varying float vAlpha;
            void main() {
                float dist = distance(gl_PointCoord, vec2(0.5));
                float strength = 1.0 - dist * 2.0;
                if (strength < 0.0) discard;
                gl_FragColor = vec4(vColor, strength * vAlpha);
            }
        `;

        const backgroundVertexShader = `
            uniform float uTime;
            attribute float aParticleType; 
            attribute float aEnsoPosition;
            attribute float aBrushIntensity;
            varying float vAlpha; 
            varying float vParticleType;
            varying vec3 vColor;
            varying float vBrushIntensity;

            void main() {
                vParticleType = aParticleType;
                vBrushIntensity = aBrushIntensity;
                
                // Create enso circle with organic imperfections
                float angle = aEnsoPosition * 6.28318;
                float radius = 15.0 + sin(aEnsoPosition * 12.0) * 1.5;
                
                // Enso gap (traditional zen circle opening)
                float gapStart = 5.5;
                float gapEnd = 6.28318;
                float gapFade = smoothstep(gapStart - 0.3, gapStart, angle) * (1.0 - smoothstep(gapEnd - 0.3, gapEnd, angle));
                
                // Rotation with time
                float rotationSpeed = uTime * 0.08;
                float rotatedAngle = angle + rotationSpeed;
                
                vec3 ensoPos = vec3(
                    cos(rotatedAngle) * radius,
                    sin(rotatedAngle) * radius,
                    sin(aEnsoPosition * 8.0 + uTime) * 0.8
                );
                
                // Add brush stroke texture displacement
                float brushNoise = sin(aEnsoPosition * 25.0 + uTime * 2.0) * aBrushIntensity * 0.5;
                ensoPos.xy += normalize(ensoPos.xy) * brushNoise;
                
                vec4 mvPosition = modelViewMatrix * vec4(ensoPos, 1.0);
                
                // Dynamic coloring based on position and time
                float colorPhase = aEnsoPosition + uTime * 0.3;
                vec3 color1 = vec3(0.02, 0.5, 0.4);   // Deep teal
                vec3 color2 = vec3(0.1, 0.8, 0.6);    // Bright emerald
                vec3 color3 = vec3(0.9, 0.95, 1.0);   // Ethereal white
                
                vec3 baseColor = mix(color1, color2, sin(colorPhase) * 0.5 + 0.5);
                vColor = mix(baseColor, color3, aBrushIntensity * gapFade);
                
                // Size based on brush intensity and distance
                float baseSize = 2.0 + aBrushIntensity * 3.0;
                float distanceScale = 120.0 / -mvPosition.z;
                gl_PointSize = baseSize * distanceScale * gapFade;
                
                // Alpha based on gap fade and brush intensity
                vAlpha = gapFade * (0.7 + aBrushIntensity * 0.3);
                
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const backgroundFragmentShader = `
            varying float vAlpha; 
            varying vec3 vColor;
            varying float vBrushIntensity;
            
            void main() {
                vec2 center = gl_PointCoord - vec2(0.5);
                float dist = length(center);
                
                // Create brush stroke texture
                float brushTexture = 1.0 - smoothstep(0.0, 0.5, dist);
                
                // Add organic edge variation
                float angle = atan(center.y, center.x);
                float edgeVariation = sin(angle * 8.0) * 0.1 + sin(angle * 16.0) * 0.05;
                float organicRadius = 0.5 + edgeVariation * vBrushIntensity;
                
                if (dist > organicRadius) discard;
                
                // Soft falloff with brush characteristics
                float strength = 1.0 - smoothstep(0.0, organicRadius, dist);
                strength *= brushTexture;
                
                // Add inner glow for mystical effect
                float innerGlow = exp(-dist * 4.0) * 0.3;
                strength += innerGlow;
                
                gl_FragColor = vec4(vColor, strength * vAlpha);
            }
        `;

        async function init() {
            initScene(); 
            initParticleScene();
            await initSextantCube();
            await createParticles();
            setupEventListeners();
            animate();
            document.getElementById('start-overlay').classList.add('ready');
        }

        function handleAccessCode(event) {
            event.preventDefault(); 
            event.stopPropagation();

            const code = "TENSION POINT";
            
            try {
                const textArea = document.createElement("textarea");
                textArea.value = code;
                textArea.style.position = "fixed"; 
                textArea.style.top = "0";
                textArea.style.left = "0";
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);

                const notification = document.getElementById('copy-notification');
                notification.classList.add('show');
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 2000);

                setTimeout(() => {
                    window.open('https://www.eventbrite.com/e/surface-tension-digital-drip-an-after-hours-art-rave-tickets-1471279469499?utm-campaign=social&utm-content=attendeeshare&utm-medium=discovery&utm-term=listing&utm-source=cp&aff=ebdsshcopyurl', '_blank');
                }, 500);
                
            } catch (err) {
                console.error('Fallback: Oops, unable to copy', err);
            }
        }
        
        // RE-ENGINEERED MOBILE AUDIO SYSTEM - Comprehensive approach
        async function createSilentAudioBuffer() {
            if (!audioContext) return null;
            
            const sampleRate = audioContext.sampleRate;
            const buffer = audioContext.createBuffer(1, sampleRate * 0.1, sampleRate); // 100ms of silence
            const channelData = buffer.getChannelData(0);
            
            // Fill with very quiet noise to help with iOS unlock
            for (let i = 0; i < channelData.length; i++) {
                channelData[i] = (Math.random() * 2 - 1) * 0.001;
            }
            
            return buffer;
        }

        async function unlockAudioContext() {
            if (!audioContext || audioContext.state === 'running') return true;
            
            try {
                // Method 1: Standard resume
                await audioContext.resume();
                
                if (audioContext.state === 'running') {
                    console.log('Audio context unlocked via resume');
                    return true;
                }
                
                // Method 2: Play silent buffer (iOS-specific)
                if (silentAudioBuffer && DEVICE_CAPABILITIES.isIOS) {
                    const source = audioContext.createBufferSource();
                    source.buffer = silentAudioBuffer;
                    source.connect(audioContext.destination);
                    source.start(0);
                    
                    await new Promise(resolve => setTimeout(resolve, 150));
                    
                    if (audioContext.state === 'running') {
                        console.log('Audio context unlocked via silent buffer');
                        return true;
                    }
                }
                
                // Method 3: Create and play oscillator briefly
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                gainNode.gain.setValueAtTime(0.001, audioContext.currentTime);
                oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.01);
                
                await new Promise(resolve => setTimeout(resolve, 20));
                
                return audioContext.state === 'running';
                
            } catch (error) {
                console.error('Audio unlock failed:', error);
                return false;
            }
        }

        async function initAudio() {
            if (audioInitialized) return;

            try {
                // Create audio context with enhanced mobile compatibility
                const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                if (!AudioContextClass) {
                    console.error('AudioContext not supported');
                    return;
                }

                audioContext = new AudioContextClass({
                    sampleRate: DEVICE_CAPABILITIES.isMobile ? 44100 : 48000,
                    latencyHint: DEVICE_CAPABILITIES.isMobile ? 'playback' : 'interactive'
                });

                // Create silent buffer for iOS unlock
                silentAudioBuffer = await createSilentAudioBuffer();

                // Attempt initial unlock
                const unlocked = await unlockAudioContext();
                
                if (!unlocked && DEVICE_CAPABILITIES.isMobile) {
                    console.warn('Initial audio unlock failed, will retry on user interaction');
                }

                // Initialize Tone.js with the created context
                Tone.setContext(audioContext);
                
                // Mobile volume optimization
                const mobileVolumeBoost = DEVICE_CAPABILITIES.isMobile ? 25 : 0;
                if (DEVICE_CAPABILITIES.isMobile) {
                    Tone.Master.volume.value = 10; // Very high for mobile
                }

                // Master effects chain
                masterReverb = new Tone.Reverb(4).toDestination();
                masterReverb.wet.value = 0.6;
                masterChorus = new Tone.Chorus(2, 2.5, 0.7).connect(masterReverb);

                // Audio synthesis with enhanced mobile optimization
                droneSynth = new Tone.FMSynth({
                    volume: -20 + mobileVolumeBoost,
                    harmonicity: 0.5,
                    modulationIndex: 10,
                    envelope: { attack: 4, decay: 0.1, sustain: 1, release: 4 },
                    modulationEnvelope: { attack: 4, decay: 0.1, sustain: 1, release: 4 }
                }).connect(masterChorus);

                const arpFilter = new Tone.AutoFilter("8n").start();
                const arpSynth = new Tone.MonoSynth({
                    volume: -8 + mobileVolumeBoost,
                    oscillator: { type: "sawtooth" },
                    filter: { Q: 2, type: "lowpass", rolloff: -24 },
                    envelope: { attack: 0.01, decay: 0.2, sustain: 0.3, release: 0.1 }
                }).connect(arpFilter).connect(masterChorus);
                
                arp = new Tone.Pattern((time, note) => {
                    arpSynth.triggerAttackRelease(note, "16n", time);
                }, ["C2", "Eb2", "G2", "Bb2"], "up");
                arp.interval = "16n";

                padFilter = new Tone.Filter(400, "lowpass").connect(masterChorus);
                padSynth = new Tone.PolySynth(Tone.FMSynth, {
                    volume: -14 + mobileVolumeBoost,
                    harmonicity: 1.5,
                    modulationIndex: 5,
                    envelope: { attack: 3, decay: 0.5, sustain: 1, release: 5 }
                }).connect(padFilter);

                disintegrateNoise = new Tone.NoiseSynth({
                    volume: -16 + mobileVolumeBoost,
                    noise: { type: 'white' },
                    envelope: { attack: 0.01, decay: 1.5, sustain: 0 }
                }).connect(masterReverb);

                climaxChime = new Tone.MetalSynth({
                    volume: -6 + mobileVolumeBoost,
                    frequency: 300,
                    envelope: { attack: 0.001, decay: 1.4, release: 0.2 },
                    harmonicity: 5.1,
                    modulationIndex: 32,
                    resonance: 4000,
                    octaves: 1.5
                }).connect(masterReverb);

                const cinematicDelay = new Tone.FeedbackDelay("8n", 0.4).connect(masterChorus);
                cinematicDelay.wet.value = 0.7;
                
                const cinematicChorus = new Tone.Chorus({
                    frequency: 1.5,
                    delayTime: 3.5,
                    depth: 0.8,
                    spread: 180
                }).connect(cinematicDelay);
                
                const cinematicFilter = new Tone.Filter({
                    type: "lowpass",
                    frequency: 2000,
                    Q: 1.4
                }).connect(cinematicChorus);

                cinematicLead = new Tone.DuoSynth({
                    volume: -16 + mobileVolumeBoost,
                    vibratoAmount: 0.2,
                    vibratoRate: 4,
                    harmonicity: 1.5,
                    voice0: {
                        oscillator: { 
                            type: 'sawtooth',
                            partials: [1, 0.5, 0.3, 0.25, 0.2]
                        },
                        envelope: { 
                            attack: 2.5, 
                            decay: 0.3, 
                            sustain: 0.8, 
                            release: 3.5 
                        },
                        filter: {
                            Q: 2,
                            type: 'lowpass',
                            rolloff: -12
                        }
                    },
                    voice1: {
                        oscillator: { 
                            type: 'pulse',
                            width: 0.3
                        },
                        envelope: { 
                            attack: 3.0, 
                            decay: 0.2, 
                            sustain: 0.6, 
                            release: 4.0 
                        },
                        filter: {
                            Q: 1.5,
                            type: 'lowpass',
                            rolloff: -12
                        }
                    }
                }).connect(cinematicFilter);

                audioInitialized = true;
                console.log('Audio system initialized successfully');

            } catch (error) {
                console.error('Audio initialization failed:', error);
                audioInitialized = false;
            }
        }

        // CORRECTED TEXT GENERATION - Restore original desktop scale, increase mobile scale
        async function getTextPoints() {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                const viewportWidth = window.innerWidth;
                const isMobile = viewportWidth < 768;
                
                if (isMobile) {
                    // CORRECTED mobile implementation - increased scale for bigger text
                    const canvasSize = 1536;
                    const fontSize = 130; // Increased font size
                    const scaling = 0.045; // INCREASED scaling for bigger mobile text
                    
                    canvas.width = canvasSize;
                    canvas.height = canvasSize;
                    ctx.font = `bold ${fontSize}px "ivypresto-display", serif`;
                    ctx.fillStyle = '#fff';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // Split text for better mobile fitting but with bigger scale
                    const words = TITLE_TEXT.split(' ');
                    const line1 = words[0];
                    const line2 = words.slice(1).join(' ');
                    
                    ctx.fillText(line1, canvasSize / 2, canvasSize / 2 - fontSize * 0.55);
                    ctx.fillText(line2, canvasSize / 2, canvasSize / 2 + fontSize * 0.55);
                    
                    const imageData = ctx.getImageData(0, 0, canvasSize, canvasSize);
                    const points = [];
                    const density = 3; // Better density for quality
                    
                    for (let y = 0; y < canvasSize; y += density) {
                        for (let x = 0; x < canvasSize; x += density) {
                            const alpha = imageData.data[(y * canvasSize + x) * 4 + 3];
                            if (alpha > 128) {
                                const worldX = (x - canvasSize / 2) * scaling;
                                const worldY = -(y - canvasSize / 2) * scaling;
                                points.push(new THREE.Vector3(worldX, worldY, 0));
                            }
                        }
                    }
                    resolve(points);
                } else {
                    // RESTORED original desktop implementation
                    const canvasSize = 2048;
                    const fontSize = 180;
                    const scaling = 0.045; // RESTORED original desktop scaling
                    
                    canvas.width = canvasSize;
                    canvas.height = canvasSize;
                    ctx.font = `bold ${fontSize}px "ivypresto-display", serif`;
                    ctx.fillStyle = '#fff';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(TITLE_TEXT, canvasSize / 2, canvasSize / 2);
                    
                    const imageData = ctx.getImageData(0, 0, canvasSize, canvasSize);
                    const points = [];
                    const density = 3;
                    
                    for (let y = 0; y < canvasSize; y += density) {
                        for (let x = 0; x < canvasSize; x += density) {
                            const alpha = imageData.data[(y * canvasSize + x) * 4 + 3];
                            if (alpha > 128) {
                                const worldX = (x - canvasSize / 2) * scaling;
                                const worldY = -(y - canvasSize / 2) * scaling;
                                points.push(new THREE.Vector3(worldX, worldY, 0));
                            }
                        }
                    }
                    resolve(points);
                }
            });
        }

        function initScene() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = FIELD_RADIUS;
            const canvas = document.getElementById('liminal-canvas');
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: !OPTIMAL_SETTINGS.isLowEnd, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(OPTIMAL_SETTINGS.pixelRatio);
            composer = new THREE.EffectComposer(renderer);
            composer.addPass(new THREE.RenderPass(scene, camera));
            bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), OPTIMAL_SETTINGS.bloomStrength, 0.5, 0.8);
            composer.addPass(bloomPass);
        }

        function initParticleScene() {
            particleScene = new THREE.Scene();
            particleCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            particleCamera.position.z = 2;
            particleRenderer = new THREE.WebGLRenderer({ canvas: document.getElementById('particle-canvas'), antialias: !OPTIMAL_SETTINGS.isLowEnd, alpha: true });
            particleRenderer.setSize(window.innerWidth, window.innerHeight);
            particleRenderer.setPixelRatio(OPTIMAL_SETTINGS.pixelRatio);
            
            // Optimized enso particle system
            const pCount = OPTIMAL_SETTINGS.backgroundParticleCount;
            const geometry = new THREE.BufferGeometry();
            const pos = new Float32Array(pCount * 3);
            const particleTypes = new Float32Array(pCount);
            const ensoPositions = new Float32Array(pCount);
            const brushIntensities = new Float32Array(pCount);
            
            for (let i = 0; i < pCount; i++) {
                const i3 = i * 3;
                
                const ensoPos = (i / pCount) * 2 * Math.PI;
                const brushCluster = Math.random() < 0.7 ? 1.0 : 0.3;
                const radiusVariation = (Math.random() - 0.5) * 2.0 * brushCluster;
                
                const radius = 15 + radiusVariation;
                pos[i3] = Math.cos(ensoPos) * radius;
                pos[i3 + 1] = Math.sin(ensoPos) * radius;
                pos[i3 + 2] = (Math.random() - 0.5) * 3.0;
                
                particleTypes[i] = Math.random() < 0.8 ? 1.0 : 0.0;
                ensoPositions[i] = ensoPos / (2 * Math.PI);
                brushIntensities[i] = Math.pow(Math.random(), 0.6) * brushCluster;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geometry.setAttribute('aParticleType', new THREE.BufferAttribute(particleTypes, 1));
            geometry.setAttribute('aEnsoPosition', new THREE.BufferAttribute(ensoPositions, 1));
            geometry.setAttribute('aBrushIntensity', new THREE.BufferAttribute(brushIntensities, 1));
            
            const material = new THREE.ShaderMaterial({
                vertexShader: backgroundVertexShader, 
                fragmentShader: backgroundFragmentShader,
                uniforms: { uTime: { value: 0 } },
                blending: THREE.AdditiveBlending, 
                transparent: true, 
                depthWrite: false
            });
            
            backgroundVisual = new THREE.Points(geometry, material);
            particleScene.add(backgroundVisual);
            
            particleComposer = new THREE.EffectComposer(particleRenderer);
            particleComposer.addPass(new THREE.RenderPass(particleScene, particleCamera));
            const secretBloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.4, 0.5, 0.1);
            particleComposer.addPass(secretBloomPass);
        }

        // OPTIMIZED SEXTANT CUBE - Fixed blow-out issue
        async function initSextantCube() {
            const canvas = document.getElementById('sextant-cube-canvas');
            if (!canvas) return;

            const size = 40;
            sextantCubeScene = new THREE.Scene();
            sextantCubeCamera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
            sextantCubeCamera.position.z = 3;

            sextantCubeRenderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
            sextantCubeRenderer.setSize(size, size);
            sextantCubeRenderer.setPixelRatio(window.devicePixelRatio);

            // Reduced particle count to prevent blow-out
            const particleCount = OPTIMAL_SETTINGS.cubeParticleCount;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);

            const color1 = new THREE.Color(0.06, 0.73, 0.51);
            const color2 = new THREE.Color(0.66, 0.33, 0.98);

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                // Create cube structure with wireframe edges
                const edge = Math.floor(Math.random() * 12); // 12 edges of a cube
                let x, y, z;
                
                // Define cube wireframe edges
                const t = Math.random();
                switch(edge) {
                    case 0: x = t * 2 - 1; y = -1; z = -1; break;
                    case 1: x = t * 2 - 1; y = 1; z = -1; break;
                    case 2: x = t * 2 - 1; y = -1; z = 1; break;
                    case 3: x = t * 2 - 1; y = 1; z = 1; break;
                    case 4: x = -1; y = t * 2 - 1; z = -1; break;
                    case 5: x = 1; y = t * 2 - 1; z = -1; break;
                    case 6: x = -1; y = t * 2 - 1; z = 1; break;
                    case 7: x = 1; y = t * 2 - 1; z = 1; break;
                    case 8: x = -1; y = -1; z = t * 2 - 1; break;
                    case 9: x = 1; y = -1; z = t * 2 - 1; break;
                    case 10: x = -1; y = 1; z = t * 2 - 1; break;
                    case 11: x = 1; y = 1; z = t * 2 - 1; break;
                    default: x = 0; y = 0; z = 0;
                }
                
                positions[i3] = x;
                positions[i3 + 1] = y;
                positions[i3 + 2] = z;

                // Subtle color interpolation
                const mixFactor = Math.random();
                const color = color1.clone().lerp(color2, mixFactor);
                colors[i3] = color.r;
                colors[i3 + 1] = color.g;
                colors[i3 + 2] = color.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            // Fixed material to prevent blow-out
            const material = new THREE.PointsMaterial({
                size: 1.5, // Reduced size
                vertexColors: true,
                blending: THREE.NormalBlending, // Changed from AdditiveBlending
                transparent: true,
                opacity: 0.6 // Reduced opacity
            });

            sextantCube = new THREE.Points(geometry, material);
            sextantCubeScene.add(sextantCube);
        }

        async function createParticles() {
            const textPoints = await getTextPoints();
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
            const sizes = new Float32Array(PARTICLE_COUNT);
            const colors = new Float32Array(PARTICLE_COUNT * 3);
            const randomness = new Float32Array(PARTICLE_COUNT);
            const textTargetPositions = new Float32Array(PARTICLE_COUNT * 3);
            const isTextParticle = new Float32Array(PARTICLE_COUNT);
            const color1 = new THREE.Color("#4338ca");
            const color2 = new THREE.Color("#a855f7");
            const color3 = new THREE.Color("#10b981");
            const textParticleIndices = new Set();
            while (textParticleIndices.size < textPoints.length * 2 && textParticleIndices.size < PARTICLE_COUNT / 3) {
                textParticleIndices.add(Math.floor(Math.random() * PARTICLE_COUNT));
            }
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                const theta = Math.random() * 2 * Math.PI;
                const phi = Math.acos((Math.random() * 2) - 1);
                const r = Math.pow(Math.random(), 0.7) * FIELD_RADIUS;
                targetPositions[i3] = r * Math.sin(phi) * Math.cos(theta);
                targetPositions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                targetPositions[i3 + 2] = r * Math.cos(phi);
                positions.set([0, 0, 0], i3);
                sizes[i] = Math.random() * 2.5 + 1.0;
                const randomColor = color1.clone().lerp(color2, Math.random());
                randomColor.lerp(color3, Math.random() * 0.4);
                colors.set([randomColor.r, randomColor.g, randomColor.b], i3);
                randomness[i] = Math.random();
                isTextParticle[i] = 0.0;
            }
            const textParticleArray = Array.from(textParticleIndices);
            textPoints.forEach((point, i) => {
                const particleIndex = textParticleArray[i % textParticleArray.length];
                if (particleIndex === undefined) return;
                const i3 = particleIndex * 3;
                isTextParticle[particleIndex] = 1.0;
                textTargetPositions.set([point.x, point.y, point.z], i3);
            });
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('aTargetPosition', new THREE.BufferAttribute(targetPositions, 3));
            geometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('aColor', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('aRandomness', new THREE.BufferAttribute(randomness, 1));
            geometry.setAttribute('aIsTextParticle', new THREE.BufferAttribute(isTextParticle, 1));
            geometry.setAttribute('aTextTargetPosition', new THREE.BufferAttribute(textTargetPositions, 3));
            const material = new THREE.ShaderMaterial({ 
                vertexShader: particleVertexShader, 
                fragmentShader: particleFragmentShader, 
                uniforms: { 
                    uTime: { value: 0 },
                    uExpansionProgress: { value: 0.0 },
                    uConvergenceProgress: { value: 0.0 },
                    uDisintegrationProgress: { value: 0.0 },
                    uDisperse: { value: 0.0 },
                    uFieldRadius: { value: FIELD_RADIUS }
                },
                transparent: true, 
                blending: THREE.AdditiveBlending, 
                depthWrite: false
            });
            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        // ENHANCED MOBILE AUDIO EVENT HANDLERS
        function setupAudioUnlockHandlers() {
            if (!DEVICE_CAPABILITIES.isMobile) return;

            const unlockEvents = ['touchstart', 'touchend', 'mousedown', 'click', 'keydown'];
            let unlockAttempts = 0;
            const maxUnlockAttempts = 5;

            const attemptUnlock = async (event) => {
                if (unlockAttempts >= maxUnlockAttempts) return;
                unlockAttempts++;

                try {
                    const success = await unlockAudioContext();
                    if (success) {
                        console.log(`Audio unlocked on attempt ${unlockAttempts} via ${event.type}`);
                        
                        // Boost volume for mobile after successful unlock
                        if (Tone.Master) {
                            Tone.Master.volume.value = 10;
                        }
                        
                        // Remove listeners after successful unlock
                        unlockEvents.forEach(eventType => {
                            document.removeEventListener(eventType, attemptUnlock);
                        });
                    }
                } catch (error) {
                    console.warn(`Audio unlock attempt ${unlockAttempts} failed:`, error);
                }
            };

            // Add listeners for all unlock events
            unlockEvents.forEach(eventType => {
                document.addEventListener(eventType, attemptUnlock, { 
                    passive: true, 
                    once: false // Don't remove automatically, we'll manage this
                });
            });
        }

        function setupEventListeners() {
            window.addEventListener('resize', debounce(onWindowResize, 250), false);
            
            const startOverlay = document.getElementById('start-overlay');
            startOverlay.addEventListener('click', async () => {
                startOverlay.style.opacity = '0';
                startOverlay.style.pointerEvents = 'none';
                
                // COMPREHENSIVE MOBILE AUDIO INITIALIZATION
                try {
                    // Initialize audio system first
                    await initAudio();
                    
                    // Setup ongoing unlock handlers for mobile
                    setupAudioUnlockHandlers();
                    
                    // Attempt initial unlock
                    if (DEVICE_CAPABILITIES.isMobile) {
                        const unlocked = await unlockAudioContext();
                        if (unlocked) {
                            console.log('Audio successfully unlocked on initialization');
                        } else {
                            console.log('Audio will unlock on next user interaction');
                        }
                    }
                    
                    // Start Tone.js transport after successful initialization
                    if (audioInitialized) {
                        await Tone.start();
                    }
                    
                    runOpeningSequence();
                    document.getElementById('mute-button').classList.add('visible');
                    
                } catch (error) {
                    console.error('Audio initialization failed:', error);
                    runOpeningSequence();
                    document.getElementById('mute-button').classList.add('visible');
                }
            }, { once: true });

            const muteButton = document.getElementById('mute-button');
            muteButton.addEventListener('click', () => {
                if (!audioInitialized) return;
                Tone.Master.mute = !Tone.Master.mute;
                muteButton.className = Tone.Master.mute ? 'muted visible' : 'unmuted visible';
            });

            const passwordForm = document.getElementById('password-form');
            const passwordInput = document.getElementById('password-input');

            passwordForm.addEventListener('submit', (e) => {
                e.preventDefault();
                checkPassword();
            });

            passwordInput.addEventListener('input', handleTyping);

            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            window.addEventListener('touchstart', handleTouchStart);

            const hintIcon = document.getElementById('hint-icon');
            const hintTooltip = document.getElementById('hint-tooltip');
            hintIcon.addEventListener('click', (e) => {
                e.stopPropagation();
                hintTooltip.classList.toggle('visible');
            });
            document.addEventListener('click', () => {
                if (hintTooltip.classList.contains('visible')) {
                    hintTooltip.classList.remove('visible');
                }
            });
        }

        function handleKeyDown(e) {
            if (isTransitioning || activeScene !== 'title') return;
            keysPressed.add(e.code);
            if (keysPressed.has('KeyS') && keysPressed.has('Digit1') && keysPressed.has('Digit0')) {
                isTransitioning = true;
                transitionToSecretPage();
            }
        }

        function handleKeyUp(e) {
            keysPressed.delete(e.code);
        }

        function handleTouchStart() {
            if (isTransitioning || activeScene !== 'title') return;
            clearTimeout(tapTimer);
            tapCount++;
            if (tapCount >= 7) {
                isTransitioning = true;
                transitionToSecretPage();
            } else {
                tapTimer = setTimeout(() => {
                    tapCount = 0;
                }, 500); 
            }
        }

        // STREAMLINED CINEMATIC TRANSITION - 3.5 seconds, sequential staging
        function transitionToSecretPage() {
            window.removeEventListener('keydown', handleKeyDown);
            window.removeEventListener('keyup', handleKeyUp);
            window.removeEventListener('touchstart', handleTouchStart);

            const riddleOverlay = document.getElementById('riddle-overlay');
            const canvasContainer = document.getElementById('liminal-canvas-container');
            const particleCanvasContainer = document.getElementById('particle-canvas-container');
            const animatedTextContainer = document.getElementById('animated-text-container');
            const socialLinksContainer = document.getElementById('social-links-container');
            
            gsap.killTweensOf(riddleOverlay);

            // **OPTIMIZED CINEMATIC TRANSITION - 3.5 seconds total**
            const masterTimeline = gsap.timeline();

            // Stage 1: Quick particle explosion (0.8s)
            if (particles) {
                masterTimeline.to(particles.material.uniforms.uDisperse, {
                    value: 30.0,
                    duration: 0.6,
                    ease: "expo.out"
                }, 0);

                masterTimeline.to(visualFeedback, {
                    glow: 6.0,
                    duration: 0.4,
                    ease: "power3.out"
                }, 0);

                // Controlled screen shake
                masterTimeline.to(document.body, {
                    x: "+=4",
                    duration: 0.03,
                    ease: "power2.inOut",
                    yoyo: true,
                    repeat: 4
                }, 0.2);
            }

            // Stage 2: Audio stingers (0.5s)
            if (audioInitialized) {
                climaxChime.triggerAttackRelease("C5", "1n", Tone.now() + 0.1);
                climaxChime.triggerAttackRelease("G4", "2n", Tone.now() + 0.3);
                
                const explosionNoise = new Tone.NoiseSynth({
                    volume: -10,
                    noise: { type: 'pink' },
                    envelope: { attack: 0.01, decay: 0.8, sustain: 0 }
                }).toDestination();
                explosionNoise.triggerAttack(Tone.now() + 0.2);
                
                // Quick audio fadeout
                setTimeout(() => {
                    Tone.Transport.stop();
                    Tone.Transport.cancel();
                    if (droneSynth) droneSynth.volume.rampTo(-Infinity, 1.0);
                    if (padSynth) padSynth.volume.rampTo(-Infinity, 1.0);
                    if (cinematicLead) cinematicLead.volume.rampTo(-Infinity, 1.0);
                    if (arp) arp.stop();
                }, 600);
            }

            // Stage 3: Camera zoom (1.0s)
            masterTimeline.to(camera, {
                fov: 25,
                duration: 1.0,
                ease: "power3.inOut",
                onUpdate: () => {
                    camera.updateProjectionMatrix();
                }
            }, 0.4);

            // Stage 4: Fade out old content (1.2s)
            masterTimeline.to([canvasContainer, riddleOverlay], {
                duration: 1.2,
                opacity: 0,
                scale: 1.4,
                filter: "blur(15px)",
                ease: "power3.inOut",
                onComplete: () => {
                    if (riddleOverlay) riddleOverlay.classList.remove('visible');
                    if (canvasContainer) canvasContainer.classList.add('hidden');
                    activeScene = 'secret';
                    
                    // Reset camera and effects
                    camera.fov = 75;
                    camera.updateProjectionMatrix();
                    gsap.set(document.body, { x: 0 });
                    
                    startTextAnimation();
                }
            }, 0.8);

            // Stage 5: Reveal new content (1.5s)
            if (particleCanvasContainer) {
                particleCanvasContainer.classList.remove('hidden');
                masterTimeline.fromTo(particleCanvasContainer, 
                    { 
                        opacity: 0, 
                        scale: 0.7, 
                        filter: 'blur(20px)',
                    },
                    { 
                        duration: 1.5, 
                        opacity: 1, 
                        scale: 1.0,
                        filter: 'blur(0px)',
                        ease: "back.out(1.2)" 
                    }, 1.8);
            }

            // Stage 6: Text entrance (1.2s)
            if (animatedTextContainer) {
                animatedTextContainer.classList.add('visible');
                masterTimeline.fromTo(animatedTextContainer, 
                    { 
                        opacity: 0, 
                        y: 80, 
                        scale: 0.8,
                        filter: 'blur(10px)'
                    },
                    { 
                        duration: 1.2, 
                        opacity: 1, 
                        y: 0,
                        scale: 1.0,
                        filter: 'blur(0px)',
                        ease: "back.out(1.4)" 
                    }, 2.3);
            }

            // Stage 7: Social links (1.0s)
            if (socialLinksContainer) {
                socialLinksContainer.classList.add('visible');
                masterTimeline.fromTo(socialLinksContainer, 
                    { opacity: 0, y: 40, scale: 0.8 },
                    { 
                        duration: 1.0, 
                        opacity: 1, 
                        y: 0,
                        scale: 1.0,
                        ease: "back.out(1.3)" 
                    }, 2.8);
            }

            // Stage 8: Effects cleanup (0.5s)
            masterTimeline.to(visualFeedback, {
                glow: 0.0,
                disperse: 0.0,
                duration: 0.5,
                ease: "power2.inOut"
            }, 3.0);

            document.getElementById('mute-button').classList.remove('visible');
        }

        function handleTyping(e) {
            if (isTransitioning) return;
            const currentInput = e.target.value.toUpperCase();
            let matchCount = 0;
            const target = "LIMINAL";
            for(let i = 0; i < currentInput.length; i++) {
                if (i < target.length && currentInput[i] === target[i]) {
                    matchCount++;
                } else {
                    matchCount = 0;
                    break;
                }
            }
            const glowAmount = (matchCount / target.length) * 0.6;
            gsap.to(visualFeedback, { glow: glowAmount, duration: 0.5, ease: 'power2.out' });

            if (CORRECT_PASSWORDS.includes(currentInput)) {
                checkPassword(true);
            }
        }
        
        function checkPassword(isAutoTrigger = false) {
            if (isTransitioning) return;
            const passwordInput = document.getElementById('password-input');
            const passwordForm = document.getElementById('password-form');
            const enteredPassword = passwordInput.value.toUpperCase().trim();

            if (isAutoTrigger || CORRECT_PASSWORDS.includes(enteredPassword)) {
                isTransitioning = true; 
                passwordInput.blur();
                
                gsap.to(visualFeedback, { 
                    glow: 1.5, 
                    duration: 0.5, 
                    ease: 'power2.out'
                });

                transitionToSecretPage();
            } else {
                passwordForm.classList.add('error');
                passwordInput.value = '';
                setTimeout(() => passwordForm.classList.remove('error'), 500);

                gsap.to(visualFeedback, { 
                    disperse: 5.0, 
                    duration: 1.5,
                    ease: 'power2.out',
                    yoyo: true,
                    repeat: 1
                });
            }
        }
        
        function startTextAnimation() {
            const textElement = document.getElementById('animated-text');
            const flickerElement = document.getElementById('flicker-text');
            const dateLeftElement = document.getElementById('event-date-left');
            const dateRightElement = document.getElementById('event-date-right');
            if (!textElement || !flickerElement || !dateLeftElement || !dateRightElement) return;
            
            textElement.textContent = "SURFACE TENSION";

            const eventTitle = encodeURIComponent("SURFACE TENSION - DIGITAL DRIP AT SEXTANT");
            const eventLocation = encodeURIComponent("539 Valencia Street, San Francisco, CA");
            const eventDetails = encodeURIComponent(
                "Experience the intersection of digital art and specialty coffee.\n\nAn immersive art showcase from 5:00 PM to 6:30 PM, featuring exclusive digital installations and signature drinks crafted for the event.\n\nThe evening then transitions into a vibrant rave space with a live DJ set beginning at 7 PM. Expect exciting surprises and special gifts throughout the night.\n\n---\n\nFollow the journey:\nInstagram: https://www.instagram.com/surfacetension.co\nTikTok: https://www.tiktok.com/@surfacetension.co\nWebsite: https://www.surfacetension.co"
            );
            const calendarUrl = `https://www.google.com/calendar/render?action=TEMPLATE&text=${eventTitle}&dates=20250726T170000/20250726T220000&location=${eventLocation}&details=${eventDetails}`;
            
            dateLeftElement.innerHTML = `<a href="${calendarUrl}" target="_blank" rel="noopener noreferrer">JULY 26TH, 2025</a>`;
            dateRightElement.innerHTML = `<a href="${calendarUrl}" target="_blank" rel="noopener noreferrer">5:00PM</a>`;

            gsap.timeline({repeat: -1, repeatDelay: 2.5})
                .to(flickerElement, {
                    duration: 0.1,
                    opacity: 0.3,
                    textShadow: '0 0 20px #10b981, 0 0 40px #10b981'
                })
                .to(flickerElement, { duration: 0.05, opacity: 1 })
                .to(flickerElement, { duration: 0.05, opacity: 0.5, delay: 0.2 })
                .to(flickerElement, { duration: 0.05, opacity: 1 })
                .to(flickerElement, { duration: 0.1, opacity: 0.2, delay: 0.5 })
                .to(flickerElement, { duration: 0.2, opacity: 1, textShadow: '0 0 10px #10b981, 0 0 20px #10b981' });
        }
        
        function runOpeningSequence() {
            const riddleOverlay = document.getElementById('riddle-overlay');
            const tl = gsap.timeline();

            if (audioInitialized) {
                Tone.Transport.bpm.value = 110; 
                Tone.Transport.start();

                droneSynth.triggerAttack("C1", Tone.now());

                const audioStartTime = "2.0s";

                const chordProgression = [
                    { time: "0:0", note: "Cm", duration: "1m" },
                    { time: "1:0", note: "Gm", duration: "1m" },
                    { time: "2:0", note: "Fm", duration: "1m" },
                    { time: "3:0", note: "Cm", duration: "1m" },
                    { time: "4:0", note: "Fm", duration: "2m" }, 
                    { time: "6:0", note: "Cm", duration: "2m" }
                ];

                new Tone.Part((time, value) => {
                    let chord;
                    switch(value.note) {
                        case "Cm": chord = ["C3", "Eb3", "G3"]; arp.values = ["C2", "Eb2", "G2", "C3"]; break;
                        case "Gm": chord = ["G3", "Bb3", "D4"]; arp.values = ["G2", "Bb2", "D3", "G3"]; break;
                        case "Fm": chord = ["F3", "Ab3", "C4"]; arp.values = ["F2", "Ab2", "C3", "F3"]; break;
                    }
                    padSynth.triggerAttackRelease(chord, value.duration, time);
                }, chordProgression).start(audioStartTime);

                arp.start(audioStartTime);
                
                // Cinematic lead melody
                const cinematicMelodySequence = new Tone.Sequence((time, note) => {
                    if (note) {
                        cinematicLead.triggerAttackRelease(note, '2n', time);
                        
                        // Dynamic filter sweep during lead notes
                        if (cinematicLead.voice0 && cinematicLead.voice0.filter) {
                            cinematicLead.voice0.filter.frequency.setValueAtTime(800, time);
                            cinematicLead.voice0.filter.frequency.exponentialRampToValueAtTime(2400, time + 1.5);
                        }
                        if (cinematicLead.voice1 && cinematicLead.voice1.filter) {
                            cinematicLead.voice1.filter.frequency.setValueAtTime(600, time);
                            cinematicLead.voice1.filter.frequency.exponentialRampToValueAtTime(1800, time + 1.5);
                        }
                    }
                }, [
                    null, null, 'C4', null, 
                    'Eb4', null, 'G4', null,
                    'Bb4', null, 'G4', 'F4',
                    'Eb4', null, 'C4', null,
                    null, 'G4', 'F4', 'Eb4',
                    'D4', null, 'C4', null
                ], '2n').start("8s");

                cinematicMelodySequence.humanize = true;
                cinematicMelodySequence.probability = 0.85;

                padSynth.volume.rampTo(-18, 0.1, audioStartTime);
                if (padFilter) {
                    padFilter.frequency.rampTo(4000, 8, Tone.now() + 2.5); 
                }
            }

            tl.to(particles.material.uniforms.uExpansionProgress, {
                value: 1.0,
                duration: 6,
                ease: 'power3.out'
            }, "start");
            
            tl.to(particles.material.uniforms.uConvergenceProgress, {
                value: 1.0,
                duration: 8.5,
                ease: 'power2.inOut',
                onStart: () => {
                    if (audioInitialized) {
                         climaxChime.triggerAttack(Tone.now() + 0.1);
                    }
                }
            }, "start+=4.0");

            tl.to(particles.material.uniforms.uDisintegrationProgress, {
                value: 1.0,
                duration: 3.5, 
                ease: 'power2.in',
                onStart: () => {
                    if (audioInitialized) {
                        disintegrateNoise.triggerAttack(Tone.now() + 0.1);
                    }
                }
            }, "start+=13.5");

            tl.to(riddleOverlay, {
                opacity: 1,
                duration: 1.5,
                ease: 'power2.out',
                onStart: () => {
                    if (riddleOverlay) riddleOverlay.classList.add('visible');
                    if(audioInitialized) {
                        const outroTime = Tone.Transport.now() + 40; 
                        padSynth.volume.rampTo(-Infinity, 5, outroTime);
                        cinematicLead.volume.rampTo(-Infinity, 6, outroTime);
                        arp.stop(outroTime + 4);
                        droneSynth.volume.rampTo(-Infinity, 8, outroTime + 1);
                        
                        Tone.Transport.stop(outroTime + 10);
                    }
                }
            }, ">-1.0");
        }
        
        function onWindowResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            composer.setSize(width, height);

            if(particleCamera) {
                particleCamera.aspect = width / height;
                particleCamera.updateProjectionMatrix();
            }
            if(particleRenderer) {
                particleRenderer.setSize(width, height);
            }
            if(particleComposer) {
                particleComposer.setSize(width, height);
            }
        }

        // -- OPTIMIZED ANIMATION LOOP
        let lastTimeUpdate = 0;
        const TIME_UPDATE_INTERVAL = 16; // ~60fps

        function animate() {
            requestAnimationFrame(animate);
            
            updatePerformanceStats();
            
            const elapsedTime = clock.getElapsedTime();
            const now = performance.now();
            
            if (activeScene === 'title' && particles) {
                // Optimized uniform updates
                if (now - lastTimeUpdate > TIME_UPDATE_INTERVAL) {
                    particles.material.uniforms.uTime.value = elapsedTime;
                    lastTimeUpdate = now;
                }
                
                particles.material.uniforms.uDisperse.value = visualFeedback.disperse;
                if (bloomPass) {
                    bloomPass.strength = OPTIMAL_SETTINGS.bloomStrength + visualFeedback.glow;
                }
                composer.render();
            } else if (activeScene === 'secret') {
                if (backgroundVisual) {
                    backgroundVisual.material.uniforms.uTime.value = elapsedTime;
                }
                if (particleCamera) {
                    // Subtle camera movement for depth
                    particleCamera.position.z = 2 + Math.sin(elapsedTime * 0.1) * 0.2;
                }
                particleComposer.render();
            }

            if (sextantCube && activeScene === 'secret') {
                sextantCube.rotation.x += 0.01;
                sextantCube.rotation.y += 0.015;
                sextantCube.rotation.z += 0.005;
                sextantCubeRenderer.render(sextantCubeScene, sextantCubeCamera);
            }
        }

        init();
    });

    // Legacy function kept for compatibility
    function copyCode(event) {
        handleAccessCode(event);
    }
    </script>
</body>
</html>
