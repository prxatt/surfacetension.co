<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Surface Tension</title>
    
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-V37GL8LNYT"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-V37GL8LNYT');
    </script>
    
    <!-- Vercel Analytics -->
    <script>
        window.va = window.va || function () { (window.vaq = window.vaq || []).push(arguments); };
    </script>
    <script defer src="/_vercel/insights/script.js"></script>
    
    <!-- Vercel Speed Insights -->
    <script>
        window.si = window.si || function () { (window.siq = window.siq || []).push(arguments); };
    </script>
    <script defer src="/_vercel/speed-insights/script.js"></script>
    
    <link rel="stylesheet" href="https://use.typekit.net/jhs3mli.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000000;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        .canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
            transition: opacity 1.5s ease-in-out;
        }
        .canvas-container.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .overlay-container {
            position: fixed;
            z-index: 2;
            color: white;
            text-align: center;
            width: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100%;
            padding: 0 5vw;
            opacity: 0;
            pointer-events: none;
            transition: opacity 1.5s ease-in-out;
        }
        .overlay-container.visible {
            opacity: 1;
            pointer-events: auto;
        }
        
        #start-overlay {
            position: fixed;
            inset: 0;
            z-index: 9999;
            background-color: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 1s ease-in-out;
            cursor: pointer;
        }
        #start-overlay.ready {
            opacity: 1;
            visibility: visible;
        }
        #start-prompt-container {
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 1rem 2rem;
            border-radius: 8px;
            background: rgba(10, 10, 10, 0.5);
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
            box-shadow: 0 0 25px rgba(255, 255, 255, 0.1);
            animation: pulse-glow 3s infinite;
        }
        #start-prompt {
            font-family: 'Inter', sans-serif;
            font-size: 1rem;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.8);
        }
        @keyframes pulse-glow {
            0% { box-shadow: 0 0 25px rgba(255, 255, 255, 0.1); }
            50% { box-shadow: 0 0 35px rgba(255, 255, 255, 0.2); }
            100% { box-shadow: 0 0 25px rgba(255, 255, 255, 0.1); }
        }

        #mute-button {
            position: fixed;
            top: 1.5rem;
            right: 1.5rem;
            z-index: 1001;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            opacity: 0;
            pointer-events: none;
        }
        #mute-button.visible {
            opacity: 0.5;
            pointer-events: auto;
        }
        #mute-button:hover {
            opacity: 1;
            transform: scale(1.1);
            background: rgba(255, 255, 255, 0.2);
        }
        #mute-button svg {
            width: 20px;
            height: 20px;
            color: white;
        }
        #unmuted-icon, #muted-icon {
            display: none;
        }
        #mute-button.unmuted #unmuted-icon { display: block; }
        #mute-button.muted #muted-icon { display: block; }

        #riddle-container {
            width: 100%;
            max-width: 650px; 
            position: relative;
            padding-bottom: 40px;
        }
        #riddle-text p {
            font-family: "ivypresto-display", serif;
            font-size: 1.1rem;
            font-weight: 400;
            line-height: 1.6;
            margin: 0.2em auto;
            color: rgba(255, 255, 255, 0.7);
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        #password-form {
            display: flex;
            align-items: center;
            width: 100%;
            max-width: 350px;
            margin: 2rem auto 0;
            position: relative;
        }
        #password-form.error {
            animation: shake 0.5s;
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }
        #password-input {
            background: transparent;
            border: none;
            outline: none;
            color: white;
            font-family: 'ivypresto-display', serif;
            font-size: 1.1rem;
            padding: 10px 15px;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            width: 100%;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            transition: border-color 0.3s;
        }
        #password-input:focus {
            border-color: rgba(255, 255, 255, 0.7);
        }
        #password-input::placeholder {
            color: rgba(255, 255, 255, 0.4);
            font-family: 'Inter', sans-serif;
            font-weight: 400;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            opacity: 0.5;
        }
        #submit-button { display: none; }
        
        #hint-container {
            position: absolute;
            bottom: 0;
            right: 0;
        }
        #hint-icon {
            width: 30px;
            height: 30px;
            border: 1px solid rgba(16, 185, 129, 0.4);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            color: rgba(16, 185, 129, 0.8);
            background: rgba(16, 185, 129, 0.05);
        }
        #hint-icon:hover {
            background: rgba(16, 185, 129, 0.15);
            border-color: rgba(16, 185, 129, 0.8);
            color: #10b981;
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(16, 185, 129, 0.3);
        }
        #hint-tooltip {
            position: absolute;
            bottom: 40px;
            right: 0;
            width: 250px;
            background: rgba(10, 10, 10, 0.9);
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.2);
            padding: 1rem;
            border-radius: 8px;
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
            text-align: left;
            color: rgba(255,255,255,0.8);
            opacity: 0;
            visibility: hidden;
            transform: translateY(10px);
            transition: all 0.3s ease;
            pointer-events: none;
        }
        #hint-tooltip.visible {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        #animated-text-container {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 90%;
            max-width: 1000px;
            padding-bottom: 120px;
        }
        #event-date-container {
            display: flex;
            justify-content: space-between;
            width: 100%; 
            margin-bottom: 0.5rem; 
        }
        .event-date-text {
            font-family: "ivypresto-display", serif;
            font-size: clamp(1.4rem, 2.5vw, 1.8rem);
            color: #a855f7;
            text-transform: uppercase;
            text-shadow: 0 0 15px rgba(168, 85, 247, 0.4);
        }
        .event-date-text a {
            color: inherit;
            text-decoration: none;
            transition: all 0.3s ease;
        }
        .event-date-text a:hover {
            color: #c084fc;
            text-shadow: 0 0 25px rgba(168, 85, 247, 0.8);
            transform: scale(1.05);
        }
        #animated-text {
            font-family: "ivypresto-display", serif;
            font-weight: 400;
            font-style: normal;
            font-size: clamp(3rem, 9vw, 7rem);
            line-height: 1.2;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: white;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.2), 0 0 30px rgba(255, 255, 255, 0.1);
            width: 100%;
            word-break: keep-all;
            text-align: center;
        }
        #subtext {
            font-family: 'Inter', sans-serif;
            font-weight: 500;
            font-size: clamp(1.1rem, 2vw, 1.5rem);
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 0.75rem; 
            opacity: 0;
            animation: fadeIn 1s ease 1s forwards;
        }
        @keyframes fadeIn { to { opacity: 1; } }
        #flicker-text {
            color: #10b981;
        }
        
        .subheading-rave {
            color: #a855f7;
        }
        
        #ticket-button {
            margin-top: 3rem;
            position: relative;
            width: 280px;
            height: 85px;
            cursor: pointer;
            border-radius: 12px;
            border: 2px solid rgba(0, 255, 255, 0.6);
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.05), rgba(0, 255, 255, 0.1));
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Inter', sans-serif;
            font-weight: 700;
            font-size: 1.3rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: #00ffff;
            text-decoration: none;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
            box-shadow: 
                0 0 30px rgba(0, 255, 255, 0.2), 
                inset 0 0 20px rgba(0, 255, 255, 0.05);
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.4);
        }
        #ticket-button::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(45deg, transparent, rgba(0, 255, 255, 0.1), transparent);
            opacity: 0.3;
            transition: opacity 0.4s ease;
        }
        #ticket-button:hover {
            border-color: rgba(0, 255, 255, 1);
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.15), rgba(0, 255, 255, 0.25));
            color: #ffffff;
            box-shadow: 
                0 0 60px rgba(0, 255, 255, 0.6), 
                inset 0 0 40px rgba(0, 255, 255, 0.15),
                0 8px 32px rgba(0, 255, 255, 0.3);
            text-shadow: 0 0 20px rgba(0, 255, 255, 1);
            transform: translateY(-3px) scale(1.03);
        }
        #ticket-button:hover::before {
            opacity: 0.8;
        }

        #access-code-wrapper {
            margin-top: 1.5rem;
            font-family: 'Inter', sans-serif;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.8rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            text-align: center;
        }
        #access-code-text {
            color: rgba(255, 255, 255, 0.8);
            font-weight: 500;
            background-color: rgba(255, 255, 255, 0.05);
            padding: 0.4rem 0.8rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-block;
            margin-top: 0.3rem;
        }
        #access-code-text:hover {
            background-color: rgba(255, 255, 255, 0.15);
            color: #fff;
            transform: scale(1.05);
        }
        #copy-notification {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #10b981;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            z-index: 100;
            opacity: 0;
            transition: all 0.5s ease;
            pointer-events: none;
            font-family: 'Inter', sans-serif;
            font-weight: 500;
            font-size: 0.9rem;
        }
        #copy-notification.show {
            opacity: 1;
            transform: translate(-50%, -10px);
        }

        #sextant-cube-container {
            margin-top: 2.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            font-family: 'Inter', sans-serif;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.75rem;
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }
        
        #sextant-cube-canvas {
            width: 40px;
            height: 40px;
        }
        
        #sextant-link {
            color: rgba(255, 255, 255, 0.7);
            text-decoration: none;
            transition: all 0.3s ease;
        }
        
        #sextant-link:hover {
            color: #fff;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
        }

        #social-links-container {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 3rem;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 1.5s ease-in-out;
        }
        #social-links-container.visible {
            opacity: 1;
            pointer-events: auto;
        }
        #social-links-container a {
            color: rgba(255, 255, 255, 0.4);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            padding: 8px;
        }
        #social-links-container a::before {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 8px;
            background: linear-gradient(45deg, 
                rgba(16, 185, 129, 0.1), 
                rgba(168, 85, 247, 0.1), 
                rgba(0, 255, 255, 0.1)
            );
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: -1;
        }
        #social-links-container a:hover {
            transform: translateY(-3px) scale(1.08);
        }
        #social-links-container a:hover::before {
            opacity: 1;
            transform: scale(1);
        }
        #social-links-container a:nth-child(1):hover {
            color: #E4405F;
        }
        #social-links-container a:nth-child(2):hover {
            color: #1DA1F2;
        }
        #social-links-container a:nth-child(3):hover {
            color: #00f2ea;
        }
        #social-links-container a:nth-child(4):hover {
            color: #1877F2;
        }
        #social-links-container svg {
            width: 20px;
            height: 20px;
            stroke-width: 1.5;
            filter: drop-shadow(0 2px 8px rgba(0,0,0,0.4));
        }

        #footer-elements {
            position: fixed;
            bottom: 0.5rem;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 2rem;
            z-index: 99;
            opacity: 0;
            pointer-events: none;
            transition: opacity 1.5s ease-in-out;
            font-family: 'Inter', sans-serif;
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.4);
        }
        #footer-elements.visible {
            opacity: 1;
            pointer-events: auto;
        }
        
        #contact-link {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: rgba(255, 255, 255, 0.5);
            text-decoration: none;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        #contact-link:hover {
            color: #10b981;
            transform: translateY(-1px);
        }
        #contact-link svg {
            width: 14px;
            height: 14px;
        }
        
        #rights-text {
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        /* Enhanced responsive adjustments for better mobile text */
        @media (max-width: 768px) {
            #animated-text {
                font-size: clamp(2.4rem, 10vw, 5rem);
                letter-spacing: 0.05em;
                line-height: 1.1;
                padding: 0 1rem;
            }
            #subtext {
                font-size: clamp(0.95rem, 3vw, 1.2rem);
            }
            #event-date-container {
                flex-direction: column;
                gap: 0.25rem;
                text-align: center;
            }
            .event-date-text {
                font-size: clamp(1.2rem, 4vw, 1.6rem);
            }
            #ticket-button {
                width: 260px;
                height: 75px;
                font-size: 1.1rem;
            }
            #social-links-container {
                gap: 2.5rem;
                bottom: 1rem;
            }
            #social-links-container svg {
                width: 18px;
                height: 18px;
            }
            #sextant-cube-container {
                margin-top: 1.8rem;
                gap: 0.5rem;
            }
            #sextant-cube-canvas {
                width: 32px;
                height: 32px;
            }
            #footer-elements {
                flex-direction: column;
                gap: 0.5rem;
                padding: 0 1rem;
                bottom: 0.3rem;
            }
        }
        @media (max-height: 500px) {
            #animated-text-container {
                padding-bottom: 60px;
            }
            #social-links-container {
                bottom: 0.5rem;
            }
        }
        
        /* Better mobile text optimization */
        @media (max-width: 480px) {
            #animated-text {
                font-size: clamp(2rem, 11vw, 4rem);
                margin: 0.3rem 0;
                padding: 0 0.5rem;
            }
            #ticket-button {
                width: 240px;
                height: 70px;
                font-size: 1rem;
            }
            .event-date-text {
                font-size: clamp(1rem, 5vw, 1.4rem);
            }
        }

    </style>
    <!-- Library Loading -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/MeshSurfaceSampler.js"></script>
</head>
<body>
    <div id="start-overlay">
        <div id="start-prompt-container">
            <div id="start-prompt">Initialize Sequence</div>
        </div>
    </div>

    <button id="mute-button" class="unmuted" aria-label="Mute or unmute audio">
        <svg id="unmuted-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M19.114 5.636a9 9 0 010 12.728M16.463 8.288a5.25 5.25 0 010 7.424M6.75 8.25l4.72-4.72a.75.75 0 011.28.53v15.88a.75.75 0 01-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.01 9.01 0 012.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75z" /></svg>
        <svg id="muted-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M17.25 9.75L19.5 12m0 0l2.25 2.25M19.5 12l2.25-2.25M19.5 12l-2.25 2.25m-10.5-6l4.72-4.72a.75.75 0 011.28.53v15.88a.75.75 0 01-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.01 9.01 0 012.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75z" /></svg>
    </button>

    <div id="liminal-canvas-container" class="canvas-container">
        <canvas id="liminal-canvas"></canvas>
    </div>
    
    <div id="particle-canvas-container" class="canvas-container hidden">
        <canvas id="particle-canvas"></canvas>
    </div>
    
    <div id="riddle-overlay" class="overlay-container">
        <div id="riddle-container">
            <div id="riddle-text">
                <p>I am the space between one world and the next,</p>
                <p>a threshold of change where realities connect.</p>
                <p>What am I?</p>
            </div>
            <form id="password-form">
                <input type="password" id="password-input" placeholder="What am I?">
                <button type="submit" id="submit-button">&rarr;</button>
            </form>
            <div id="hint-container">
                <div id="hint-tooltip">The threshold exists where coffee meets consciousnessâ€”seek wisdom from the keepers of any Sextant Coffee sanctuary, or let the digital oracle reveal what lies between worlds.</div>
                <div id="hint-icon" aria-label="Show hint">?</div>
            </div>
        </div>
    </div>

    <div id="animated-text-container" class="overlay-container">
        <div id="event-date-container">
            <span class="event-date-text" id="event-date-left"></span>
            <span class="event-date-text" id="event-date-right"></span>
        </div>
        <h1 id="animated-text"></h1>
        <p id="subtext"><span id="flicker-text">Digital Drip</span> : <span class="subheading-rave">An After-Hours Art Rave</span></p>
        
        <a id="ticket-button" href="https://www.eventbrite.com/e/surface-tension-digital-drip-an-after-hours-art-rave-tickets-1471279469499?utm-campaign=social&utm-content=attendeeshare&utm-medium=discovery&utm-term=listing&utm-source=cp&aff=ebdsshcopyurl" target="_blank" rel="noopener noreferrer" aria-label="Purchase Tickets">
            TICKETS
        </a>

        <div id="access-code-wrapper">
            ACCESS CODE: <span id="access-code-text" onclick="copyCode(event)">TENSIONPOINT</span>
        </div>

        <div id="sextant-cube-container">
            <canvas id="sextant-cube-canvas"></canvas>
            <a href="https://www.google.com/maps/place/539+Valencia+St,+San+Francisco,+CA+94110/@37.7625,-122.421,17z" target="_blank" rel="noopener noreferrer" id="sextant-link">Sextant Coffee Roasters</a>
        </div>
    </div>

    <div id="social-links-container">
        <a href="https://www.instagram.com/surfacetension.co" target="_blank" rel="noopener noreferrer" aria-label="Instagram">
            <svg fill="currentColor" viewBox="0 0 24 24"><path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.85s-.011 3.584-.069 4.85c-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07s-3.584-.012-4.85-.07c-3.252-.148-4.771-1.691-4.919-4.919-.058-1.265-.07-1.645-.07-4.85s.012-3.584.07-4.85c.148-3.225 1.664-4.771 4.919-4.919C8.416 2.175 8.796 2.163 12 2.163zm0 1.802c-3.143 0-3.505.012-4.73.068-2.693.123-3.995 1.424-4.118 4.118-.056 1.225-.068 1.586-.068 4.73s.012 3.505.068 4.73c.123 2.693 1.424 3.995 4.118 4.118 1.225.056 1.586.068 4.73.068s3.505-.012 4.73-.068c2.693-.123 3.995-1.424 4.118-4.118.056-1.225.068-1.586.068-4.73s-.012-3.505-.068-4.73c-.123-2.693-1.424-3.995-4.118-4.118-1.225-.056-1.586-.068-4.73-.068zm0 3.888c-2.402 0-4.35 1.948-4.35 4.35s1.948 4.35 4.35 4.35 4.35-1.948 4.35-4.35-1.948-4.35-4.35-4.35zm0 7.167c-1.553 0-2.817-1.264-2.817-2.817s1.264-2.817 2.817-2.817 2.817 1.264 2.817 2.817-1.264 2.817-2.817 2.817zm4.965-7.332c-.608 0-1.1.492-1.1 1.1s.492 1.1 1.1 1.1 1.1-.492 1.1-1.1-.492-1.1-1.1-1.1z"></path></svg>
        </a>
        <a href="https://www.twitter.com/surfacetensi_n" target="_blank" rel="noopener noreferrer" aria-label="Twitter">
            <svg fill="currentColor" viewBox="0 0 24 24"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"></path></svg>
        </a>
        <a href="https://www.tiktok.com/@surfacetension.co" target="_blank" rel="noopener noreferrer" aria-label="TikTok">
            <svg fill="currentColor" viewBox="0 0 24 24"><path d="M19.59 6.69a4.83 4.83 0 0 1-3.77-4.25V2h-3.45v13.67a2.89 2.89 0 0 1-5.2 1.74 2.89 2.89 0 0 1 2.31-4.64 2.93 2.93 0 0 1 .88.13V9.4a6.84 6.84 0 0 0-1-.05A6.33 6.33 0 0 0 5 20.1a6.34 6.34 0 0 0 10.86-4.43v-7a8.16 8.16 0 0 0 4.77 1.52v-3.4a4.85 4.85 0 0 1-1-.1z"/></svg>
        </a>
        <a href="https://www.facebook.com/profile.php?id=61577915426183" target="_blank" rel="noopener noreferrer" aria-label="Facebook">
            <svg fill="currentColor" viewBox="0 0 24 24"><path d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z"/></svg>
        </a>
    </div>

    <div id="footer-elements">
        <a id="contact-link" href="mailto:connect.surfacetension@gmail.com">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 8l7.89 4.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"></path>
            </svg>
            Contact Us
        </a>
        <div id="rights-text">All Rights Reserved</div>
    </div>

    <div id="copy-notification">Code Copied to Clipboard!</div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // -- Configuration --
        const TITLE_TEXT = "SURFACE TENSION";
        const CORRECT_PASSWORDS = ['LIMINAL', 'LIMINAL SPACE'];

        // -- Global State --
        const clock = new THREE.Clock();
        let activeScene = 'title';
        let isTransitioning = false;
        
        // -- Scene Variables --
        let scene, camera, renderer, particles, composer, bloomPass;
        let particleScene, particleCamera, particleRenderer, particleComposer, backgroundVisual;
        let sextantCubeScene, sextantCubeCamera, sextantCubeRenderer, sextantCube;
        
        // -- Simplified Mobile Audio Management --
        let audioInitialized = false;
        let audioContext = null;
        let droneSynth, arp, padSynth, disintegrateNoise, climaxChime, masterReverb, masterChorus, padFilter, cinematicLead;

        let visualFeedback = { disperse: 0, glow: 0 };

        // -- Bypass State --
        const keysPressed = new Set();
        let tapCount = 0;
        let tapTimer = null;

        // -- Enhanced device capability detection --
        function getDeviceCapabilities() {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            
            const userAgent = navigator.userAgent;
            const isIPhone = /iPhone/.test(userAgent);
            const isIPad = /iPad/.test(userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
            const isAndroidPhone = /Android/.test(userAgent) && !/tablet/i.test(userAgent);
            const isAndroidTablet = /Android/.test(userAgent) && /tablet/i.test(userAgent);
            const isSafari = /Safari/.test(userAgent) && !/Chrome/.test(userAgent);
            const isChrome = /Chrome/.test(userAgent);
            const isArc = /Arc/.test(userAgent);
            
            const capabilities = {
                maxTextureSize: gl ? gl.getParameter(gl.MAX_TEXTURE_SIZE) : 1024,
                devicePixelRatio: window.devicePixelRatio,
                screenWidth: window.innerWidth,
                screenHeight: window.innerHeight,
                isMobile: isIPhone || isAndroidPhone || 
                         /webOS|BlackBerry|IEMobile|Opera Mini/i.test(userAgent),
                isTablet: isIPad || isAndroidTablet,
                isIOS: isIPhone || isIPad,
                isSafari: isSafari,
                isChrome: isChrome,
                isArc: isArc,
                isTouchDevice: ('ontouchstart' in window) || 
                              (navigator.maxTouchPoints > 0) || 
                              (navigator.msMaxTouchPoints > 0),
                isLowEnd: false,
                memoryInfo: navigator.deviceMemory || 4,
                hasAudioContext: !!(window.AudioContext || window.webkitAudioContext)
            };
            
            capabilities.isLowEnd = capabilities.isMobile || 
                                   capabilities.screenWidth < 768 || 
                                   capabilities.devicePixelRatio < 1.5 ||
                                   capabilities.maxTextureSize < 2048 ||
                                   capabilities.memoryInfo < 4;
            
            return capabilities;
        }

        const DEVICE_CAPABILITIES = getDeviceCapabilities();

        function debounce(func, wait, immediate) {
            let timeout;
            return function() {
                const context = this, args = arguments;
                const later = function() {
                    timeout = null;
                    if (!immediate) func.apply(context, args);
                };
                const callNow = immediate && !timeout;
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
                if (callNow) func.apply(context, args);
            };
        };

        // Optimized particle count for better performance
        function getDynamicParticleCount() {
            const width = window.innerWidth;
            const dpr = window.devicePixelRatio;
            const memoryInfo = DEVICE_CAPABILITIES.memoryInfo;

            // More aggressive optimization for better performance
            if (DEVICE_CAPABILITIES.isLowEnd || width < 768) {
                return 30000; // Reduced for low-end devices
            } else if (width < 1200 || memoryInfo < 6) {
                return 60000; // Moderate for mid-range
            } else if (width < 1920) {
                return 80000; // Good for higher-end
            }
            return 100000; // Maximum for powerful devices (reduced from 150k)
        }
        const PARTICLE_COUNT = getDynamicParticleCount();
        const FIELD_RADIUS = 100;

        /*
         * ==================================
         * == ORIGINAL SHADER CODE (PRESERVED) ==
         * ==================================
         */
        const particleVertexShader = `
            uniform float uTime;
            uniform float uExpansionProgress;
            uniform float uConvergenceProgress;
            uniform float uDisintegrationProgress;
            uniform float uFieldRadius;
            uniform float uDisperse;

            attribute float aSize;
            attribute vec3 aColor;
            attribute vec3 aTargetPosition;
            attribute float aRandomness;
            attribute float aIsTextParticle;
            attribute vec3 aTextTargetPosition;

            varying vec3 vColor;
            varying float vAlpha;

            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            float snoise(vec3 v) {
                const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i  = floor(v + dot(v, C.yyy));
                vec3 x0 = v - i + dot(i, C.xxx);
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min(g.xyz, l.zxy);
                vec3 i2 = max(g.xyz, l.zxy);
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;
                i = mod289(i);
                vec4 p = permute(permute(permute(
                            i.z + vec4(0.0, i1.z, i2.z, 1.0))
                        + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                        + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                float n_ = 0.142857142857;
                vec3 ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_);
                vec4 x = x_ * ns.x + ns.yyyy;
                vec4 y = y_ * ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4(x.xy, y.xy);
                vec4 b1 = vec4(x.zw, y.zw);
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
                vec3 p0 = vec3(a0.xy,h.x);
                vec3 p1 = vec3(a0.zw,h.y);
                vec3 p2 = vec3(a1.xy,h.z);
                vec3 p3 = vec3(a1.zw,h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
            }
            
            void main() {
                vec3 chaoticPos = aTargetPosition;
                float noiseFactor = snoise(vec3(chaoticPos.xy * 0.05, uTime * 0.1 + aRandomness * 5.0));
                chaoticPos.z += noiseFactor * 2.0;
                chaoticPos.x += snoise(vec3(chaoticPos.yz * 0.05, uTime * 0.1)) * 0.5;
                chaoticPos.y += snoise(vec3(chaoticPos.xz * 0.05, uTime * 0.1)) * 0.5;
                float speed = uTime * 2.0;
                vec3 drift = vec3(0.0);
                if (length(aTargetPosition) > 0.0) {
                    drift = normalize(aTargetPosition) * speed;
                }
                float fieldDiameter = uFieldRadius * 2.0;
                chaoticPos = mod(chaoticPos + drift + uFieldRadius, fieldDiameter) - uFieldRadius;
                vec3 pos = mix(vec3(0.0), chaoticPos, uExpansionProgress);
                
                float convergenceFactor = smoothstep(0.0, 1.0, uConvergenceProgress);
                float disintegrationFactor = smoothstep(0.0, 1.0, uDisintegrationProgress);

                if (aIsTextParticle > 0.5) {
                    vec3 convergedPos = mix(pos, aTextTargetPosition, convergenceFactor);
                    pos = mix(convergedPos, chaoticPos, disintegrationFactor);
                }
                
                pos.x += snoise(vec3(pos.y * 0.5, uTime * 2.0, aRandomness)) * uDisperse;
                pos.y += snoise(vec3(pos.z * 0.5, uTime * 2.0, aRandomness)) * uDisperse;
                
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_PointSize = aSize * (200.0 / -mvPosition.z);
                float depth = -mvPosition.z;
                vAlpha = smoothstep(uFieldRadius * 1.5, uFieldRadius * 0.5, depth); 
                vAlpha *= uExpansionProgress;
                
                if (aIsTextParticle > 0.5) {
                    float textVisibility = convergenceFactor * (1.0 - disintegrationFactor);
                    vAlpha = mix(vAlpha, 0.9, textVisibility);
                    vColor = mix(aColor, vec3(1.5, 1.5, 1.5), textVisibility);
                } else {
                    vColor = aColor;
                }
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const particleFragmentShader = `
            varying vec3 vColor;
            varying float vAlpha;
            void main() {
                float dist = distance(gl_PointCoord, vec2(0.5));
                float strength = 1.0 - dist * 2.0;
                if (strength < 0.0) discard;
                gl_FragColor = vec4(vColor, strength * vAlpha);
            }
        `;

        // Background visual from Slide 10 finale animation
        const finaleVertexShader = `
            uniform float uTime;
            attribute float aParticleType;
            varying float vAlpha;
            varying float vParticleType;
            varying vec3 vColor;

            void main() {
                vParticleType = aParticleType;
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);

                float zFactor = 1.0 - clamp(abs(mvPosition.z / 20.0), 0.0, 1.0);
                float pSize = (zFactor * zFactor) * 2.0 + 0.5;
                gl_PointSize = pSize;
                vAlpha = zFactor;

                vec3 greenHaloColor = vec3(0.06, 0.71, 0.51);
                vec3 greenCenterColor = vec3(0.8, 1.0, 0.9);
                vec3 platinumHaloColor = vec3(0.6, 0.65, 0.75);
                vec3 platinumCenterColor = vec3(1.0, 1.0, 1.0);

                vec3 greenColor = mix(greenCenterColor, greenHaloColor, 0.5);
                vec3 platinumColor = mix(platinumCenterColor, platinumHaloColor, 0.5);
                vColor = mix(greenColor, platinumColor, aParticleType);

                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const finaleFragmentShader = `
            varying float vAlpha;
            varying vec3 vColor;

            void main() {
                float dist = distance(gl_PointCoord, vec2(0.5));
                if (dist > 0.5) discard;
                float strength = 1.0 - dist * 2.0;
                gl_FragColor = vec4(vColor, strength * vAlpha);
            }
        `;
        
        async function init() {
            initScene(); 
            initParticleScene();
            await initSextantCube();
            await createParticles();
            setupEventListeners();
            animate();
            document.getElementById('start-overlay').classList.add('ready');
        }
        
        // Ultra-aggressive mobile audio with maximum dB for iOS
        async function initAudio() {
            if (audioInitialized) return true;

            try {
                // Immediate iOS audio context creation and unlock
                if (DEVICE_CAPABILITIES.isIOS) {
                    if (!audioContext) {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    
                    // Aggressive immediate resume for iOS
                    if (audioContext.state === 'suspended') {
                        await audioContext.resume();
                        console.log('iOS Audio Context resumed');
                    }
                    
                    // Force iOS audio activation with silent sound
                    const silentBuffer = audioContext.createBuffer(1, 1, 22050);
                    const silentSource = audioContext.createBufferSource();
                    silentSource.buffer = silentBuffer;
                    silentSource.connect(audioContext.destination);
                    silentSource.start();
                }

                await Tone.start();
                console.log('Tone.js started successfully');
                
                // MAXIMUM VOLUME SETTINGS - Ultra aggressive for mobile
                if (DEVICE_CAPABILITIES.isIOS) {
                    Tone.Master.volume.value = 40; // MAXIMUM iOS boost
                    console.log('iOS audio volume set to MAXIMUM');
                } else if (DEVICE_CAPABILITIES.isMobile) {
                    Tone.Master.volume.value = 35; // Maximum mobile
                } else if (DEVICE_CAPABILITIES.isTablet) {
                    Tone.Master.volume.value = 15;
                } else {
                    // Desktop - normal levels to prevent clipping
                    Tone.Master.volume.value = 0;
                }

                masterReverb = new Tone.Reverb(4).toDestination();
                masterReverb.wet.value = 0.6;
                masterChorus = new Tone.Chorus(2, 2.5, 0.7).connect(masterReverb);

                // MOBILE VOLUME BOOST - Add 30dB for mobile devices
                const mobileBoost = DEVICE_CAPABILITIES.isMobile ? 30 : 0;

                droneSynth = new Tone.FMSynth({
                    volume: -24 + mobileBoost,
                    harmonicity: 0.5,
                    modulationIndex: 10,
                    envelope: { attack: 4, decay: 0.1, sustain: 1, release: 4 },
                    modulationEnvelope: { attack: 4, decay: 0.1, sustain: 1, release: 4 }
                }).connect(masterChorus);

                const arpFilter = new Tone.AutoFilter("8n").start();
                const arpSynth = new Tone.MonoSynth({
                    volume: -12 + mobileBoost,
                    oscillator: { type: "sawtooth" },
                    filter: { Q: 2, type: "lowpass", rolloff: -24 },
                    envelope: { attack: 0.01, decay: 0.2, sustain: 0.3, release: 0.1 }
                }).connect(arpFilter).connect(masterChorus);
                arp = new Tone.Pattern((time, note) => {
                    arpSynth.triggerAttackRelease(note, "16n", time);
                }, ["C2", "Eb2", "G2", "Bb2"], "up");
                arp.interval = "16n";

                padFilter = new Tone.Filter(400, "lowpass").connect(masterChorus);
                padSynth = new Tone.PolySynth(Tone.FMSynth, {
                    volume: -18 + mobileBoost,
                    harmonicity: 1.5,
                    modulationIndex: 5,
                    envelope: { attack: 3, decay: 0.5, sustain: 1, release: 5 }
                }).connect(padFilter);

                disintegrateNoise = new Tone.NoiseSynth({
                    volume: -20 + mobileBoost,
                    noise: { type: 'white' },
                    envelope: { attack: 0.01, decay: 1.5, sustain: 0 }
                }).connect(masterReverb);

                climaxChime = new Tone.MetalSynth({
                    volume: -10 + mobileBoost,
                    frequency: 300,
                    envelope: { attack: 0.001, decay: 1.4, release: 0.2 },
                    harmonicity: 5.1,
                    modulationIndex: 32,
                    resonance: 4000,
                    octaves: 1.5
                }).connect(masterReverb);

                // Restored cinematicLead from original
                const cinematicDelay = new Tone.FeedbackDelay("8n", 0.4).connect(masterChorus);
                cinematicDelay.wet.value = 0.7;
                
                const cinematicChorus = new Tone.Chorus({
                    frequency: 1.5,
                    delayTime: 3.5,
                    depth: 0.8,
                    spread: 180
                }).connect(cinematicDelay);
                
                const cinematicFilter = new Tone.Filter({
                    type: "lowpass",
                    frequency: 2000,
                    Q: 1.4
                }).connect(cinematicChorus);

                cinematicLead = new Tone.DuoSynth({
                    volume: -20 + mobileBoost,
                    vibratoAmount: 0.2,
                    vibratoRate: 4,
                    harmonicity: 1.5,
                    voice0: {
                        oscillator: { 
                            type: 'sawtooth',
                            partials: [1, 0.5, 0.3, 0.25, 0.2]
                        },
                        envelope: { 
                            attack: 2.5, 
                            decay: 0.3, 
                            sustain: 0.8, 
                            release: 3.5 
                        },
                        filter: {
                            Q: 2,
                            type: 'lowpass',
                            rolloff: -12
                        }
                    },
                    voice1: {
                        oscillator: { 
                            type: 'pulse',
                            width: 0.3
                        },
                        envelope: { 
                            attack: 3.0, 
                            decay: 0.2, 
                            sustain: 0.6, 
                            release: 4.0 
                        },
                        filter: {
                            Q: 1.5,
                            type: 'lowpass',
                            rolloff: -12
                        }
                    }
                }).connect(cinematicFilter);

                audioInitialized = true;
                console.log('Audio initialization completed successfully');
                return true;
                
            } catch (error) {
                console.error('Audio initialization failed:', error);
                return false;
            }
        }

        async function getTextPoints() {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const canvasSize = 2048;
                canvas.width = canvasSize;
                canvas.height = canvasSize;
                
                // MOBILE PARTICLE TEXT SIZE FIX: Halved for mobile devices
                let fontSize = 200;
                let scaleFactor = 0.08;
                
                if (DEVICE_CAPABILITIES.isMobile) {
                    fontSize = 70; // HALF the previous size (was 140)
                    scaleFactor = 0.0225; // HALF the previous scaling (was 0.045)
                } else if (DEVICE_CAPABILITIES.isTablet) {
                    fontSize = 160;
                    scaleFactor = 0.055;
                }
                
                ctx.font = `${fontSize}px "ivypresto-display"`;
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(TITLE_TEXT, canvasSize / 2, canvasSize / 2);
                const imageData = ctx.getImageData(0, 0, canvasSize, canvasSize);
                const points = [];
                const density = 4;
                for (let y = 0; y < canvasSize; y += density) {
                    for (let x = 0; x < canvasSize; x += density) {
                        const alpha = imageData.data[(y * canvasSize + x) * 4 + 3];
                        if (alpha > 128) {
                            const worldX = (x - canvasSize / 2) * scaleFactor;
                            const worldY = -(y - canvasSize / 2) * scaleFactor;
                            points.push(new THREE.Vector3(worldX, worldY, 0));
                        }
                    }
                }
                resolve(points);
            });
        }

        async function initSextantCube() {
            const canvas = document.getElementById('sextant-cube-canvas');
            if (!canvas) return;

            const size = 40;
            sextantCubeScene = new THREE.Scene();
            sextantCubeCamera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
            sextantCubeCamera.position.z = 3;

            sextantCubeRenderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
            sextantCubeRenderer.setSize(size, size);
            sextantCubeRenderer.setPixelRatio(window.devicePixelRatio);

            const particleCount = DEVICE_CAPABILITIES.isLowEnd ? 1500 : 2500;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);

            const color1 = new THREE.Color(0.06, 0.73, 0.51);
            const color2 = new THREE.Color(0.66, 0.33, 0.98);

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                const edge = Math.floor(Math.random() * 12);
                let x, y, z;
                
                const t = Math.random();
                switch(edge) {
                    case 0: x = t * 2 - 1; y = -1; z = -1; break;
                    case 1: x = t * 2 - 1; y = 1; z = -1; break;
                    case 2: x = t * 2 - 1; y = -1; z = 1; break;
                    case 3: x = t * 2 - 1; y = 1; z = 1; break;
                    case 4: x = -1; y = t * 2 - 1; z = -1; break;
                    case 5: x = 1; y = t * 2 - 1; z = -1; break;
                    case 6: x = -1; y = t * 2 - 1; z = 1; break;
                    case 7: x = 1; y = t * 2 - 1; z = 1; break;
                    case 8: x = -1; y = -1; z = t * 2 - 1; break;
                    case 9: x = 1; y = -1; z = t * 2 - 1; break;
                    case 10: x = -1; y = 1; z = t * 2 - 1; break;
                    case 11: x = 1; y = 1; z = t * 2 - 1; break;
                    default: x = 0; y = 0; z = 0;
                }
                
                positions[i3] = x;
                positions[i3 + 1] = y;
                positions[i3 + 2] = z;

                const mixFactor = Math.random();
                const color = color1.clone().lerp(color2, mixFactor);
                colors[i3] = color.r;
                colors[i3 + 1] = color.g;
                colors[i3 + 2] = color.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 1.5,
                vertexColors: true,
                blending: THREE.NormalBlending,
                transparent: true,
                opacity: 0.6
            });

            sextantCube = new THREE.Points(geometry, material);
            sextantCubeScene.add(sextantCube);
        }

        function initScene() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = FIELD_RADIUS;
            const canvas = document.getElementById('liminal-canvas');
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            composer = new THREE.EffectComposer(renderer);
            composer.addPass(new THREE.RenderPass(scene, camera));
            bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.6, 0.5, 0.8);
            composer.addPass(bloomPass);
        }

        function initParticleScene() {
            particleScene = new THREE.Scene();
            particleCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            particleCamera.position.z = 2;
            particleRenderer = new THREE.WebGLRenderer({ canvas: document.getElementById('particle-canvas'), antialias: true, alpha: true });
            particleRenderer.setSize(window.innerWidth, window.innerHeight);
            particleRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            // Optimized finale animation particle count for performance
            const pCount = DEVICE_CAPABILITIES.isLowEnd ? 40000 : 65000;
            const geometry = new THREE.BufferGeometry();
            const pos = new Float32Array(pCount * 3);
            const particleTypes = new Float32Array(pCount);
            
            for (let i = 0; i < pCount; i++) {
                const i3 = i * 3;
                const r = Math.random() * 30;
                const a = Math.random() * Math.PI * 2;
                pos[i3] = r * Math.cos(a);
                pos[i3 + 1] = r * Math.sin(a);
                pos[i3 + 2] = (Math.random() - .5) * 12;
                particleTypes[i] = Math.random() < 0.2 ? 1.0 : 0.0;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geometry.setAttribute('aParticleType', new THREE.BufferAttribute(particleTypes, 1));
            
            const material = new THREE.ShaderMaterial({
                vertexShader: finaleVertexShader,
                fragmentShader: finaleFragmentShader,
                uniforms: { uTime: { value: 0 } },
                blending: THREE.AdditiveBlending,
                transparent: true,
                depthWrite: false
            });
            
            backgroundVisual = new THREE.Points(geometry, material);
            particleScene.add(backgroundVisual);
            
            particleComposer = new THREE.EffectComposer(particleRenderer);
            particleComposer.addPass(new THREE.RenderPass(particleScene, particleCamera));
            const secretBloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.3, 0.5, 0.1);
            particleComposer.addPass(secretBloomPass);
        }

        async function createParticles() {
            const textPoints = await getTextPoints();
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
            const sizes = new Float32Array(PARTICLE_COUNT);
            const colors = new Float32Array(PARTICLE_COUNT * 3);
            const randomness = new Float32Array(PARTICLE_COUNT);
            const textTargetPositions = new Float32Array(PARTICLE_COUNT * 3);
            const isTextParticle = new Float32Array(PARTICLE_COUNT);
            const color1 = new THREE.Color("#4338ca");
            const color2 = new THREE.Color("#a855f7");
            const color3 = new THREE.Color("#10b981");
            const textParticleIndices = new Set();
            while (textParticleIndices.size < textPoints.length * 2 && textParticleIndices.size < PARTICLE_COUNT / 3) {
                textParticleIndices.add(Math.floor(Math.random() * PARTICLE_COUNT));
            }
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                const theta = Math.random() * 2 * Math.PI;
                const phi = Math.acos((Math.random() * 2) - 1);
                const r = Math.pow(Math.random(), 0.7) * FIELD_RADIUS;
                targetPositions[i3] = r * Math.sin(phi) * Math.cos(theta);
                targetPositions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                targetPositions[i3 + 2] = r * Math.cos(phi);
                positions.set([0, 0, 0], i3);
                sizes[i] = Math.random() * 2.5 + 1.0;
                const randomColor = color1.clone().lerp(color2, Math.random());
                randomColor.lerp(color3, Math.random() * 0.4);
                colors.set([randomColor.r, randomColor.g, randomColor.b], i3);
                randomness[i] = Math.random();
                isTextParticle[i] = 0.0;
            }
            const textParticleArray = Array.from(textParticleIndices);
            textPoints.forEach((point, i) => {
                const particleIndex = textParticleArray[i % textParticleArray.length];
                if (particleIndex === undefined) return;
                const i3 = particleIndex * 3;
                isTextParticle[particleIndex] = 1.0;
                textTargetPositions.set([point.x, point.y, point.z], i3);
            });
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('aTargetPosition', new THREE.BufferAttribute(targetPositions, 3));
            geometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('aColor', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('aRandomness', new THREE.BufferAttribute(randomness, 1));
            geometry.setAttribute('aIsTextParticle', new THREE.BufferAttribute(isTextParticle, 1));
            geometry.setAttribute('aTextTargetPosition', new THREE.BufferAttribute(textTargetPositions, 3));
            const material = new THREE.ShaderMaterial({ 
                vertexShader: particleVertexShader, 
                fragmentShader: particleFragmentShader, 
                uniforms: { 
                    uTime: { value: 0 },
                    uExpansionProgress: { value: 0.0 },
                    uConvergenceProgress: { value: 0.0 },
                    uDisintegrationProgress: { value: 0.0 },
                    uDisperse: { value: 0.0 },
                    uFieldRadius: { value: FIELD_RADIUS }
                },
                transparent: true, 
                blending: THREE.AdditiveBlending, 
                depthWrite: false
            });
            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function setupEventListeners() {
            window.addEventListener('resize', debounce(onWindowResize, 250), false);
            
            const startOverlay = document.getElementById('start-overlay');
            startOverlay.addEventListener('click', async () => {
                startOverlay.style.opacity = '0';
                startOverlay.style.pointerEvents = 'none';
                
                // ULTRA-AGGRESSIVE MOBILE AUDIO - Multiple unlock strategies
                try {
                    const audioSuccess = await initAudio();
                    
                    // MAXIMUM MOBILE AUDIO UNLOCK with multiple attempts
                    if (DEVICE_CAPABILITIES.isMobile && audioSuccess) {
                        console.log('Executing ultra-aggressive mobile audio unlock...');
                        
                        // Strategy 1: Multiple context resume attempts
                        for (let i = 0; i < 5; i++) {
                            setTimeout(async () => {
                                try {
                                    if (audioContext && audioContext.state === 'suspended') {
                                        await audioContext.resume();
                                        console.log(`Mobile audio context resumed (attempt ${i + 1})`);
                                    }
                                    if (Tone.context.state === 'suspended') {
                                        await Tone.context.resume();
                                        console.log(`Tone context resumed (attempt ${i + 1})`);
                                    }
                                } catch (e) {
                                    console.warn(`Mobile audio unlock attempt ${i + 1} failed:`, e);
                                }
                            }, i * 100);
                        }
                        
                        // Strategy 2: Force maximum volume immediately
                        Tone.Master.volume.value = 50; // ULTRA maximum
                        
                        // Strategy 3: Play multiple test sounds with different frequencies
                        setTimeout(() => {
                            try {
                                [50, 100, 200, 440].forEach((freq, i) => {
                                    setTimeout(() => {
                                        const testOsc = new Tone.Oscillator(freq, "sine").toDestination();
                                        testOsc.volume.value = -30;
                                        testOsc.start();
                                        testOsc.stop("+0.05");
                                        console.log(`Mobile test sound ${freq}Hz played`);
                                    }, i * 50);
                                });
                            } catch (e) {
                                console.warn('Mobile test sounds failed:', e);
                            }
                        }, 200);
                        
                        // Strategy 4: Continuous volume boost for mobile
                        const mobileVolumeBooster = setInterval(() => {
                            if (DEVICE_CAPABILITIES.isMobile) {
                                Tone.Master.volume.value = Math.max(Tone.Master.volume.value, 45);
                            }
                        }, 1000);
                        
                        // Clear booster after 10 seconds
                        setTimeout(() => clearInterval(mobileVolumeBooster), 10000);
                    }
                    
                    runOpeningSequence();
                    document.getElementById('mute-button').classList.add('visible');
                    
                } catch (error) {
                    console.error('Audio initialization failed:', error);
                    runOpeningSequence();
                    document.getElementById('mute-button').classList.add('visible');
                }
            }, { once: true });

            const muteButton = document.getElementById('mute-button');
            muteButton.addEventListener('click', () => {
                if (!audioInitialized) return;
                Tone.Master.mute = !Tone.Master.mute;
                muteButton.className = Tone.Master.mute ? 'muted visible' : 'unmuted visible';
            });

            const passwordForm = document.getElementById('password-form');
            const passwordInput = document.getElementById('password-input');

            passwordForm.addEventListener('submit', (e) => {
                e.preventDefault();
                checkPassword();
            });

            passwordInput.addEventListener('input', handleTyping);

            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            window.addEventListener('touchstart', handleTouchStart);

            const hintIcon = document.getElementById('hint-icon');
            const hintTooltip = document.getElementById('hint-tooltip');
            hintIcon.addEventListener('click', (e) => {
                e.stopPropagation();
                hintTooltip.classList.toggle('visible');
            });
            document.addEventListener('click', () => {
                if (hintTooltip.classList.contains('visible')) {
                    hintTooltip.classList.remove('visible');
                }
            });
        }

        function handleKeyDown(e) {
            if (isTransitioning || activeScene !== 'title') return;
            keysPressed.add(e.code);
            if (keysPressed.has('KeyS') && keysPressed.has('Digit1') && keysPressed.has('Digit0')) {
                isTransitioning = true;
                transitionToSecretPage();
            }
        }

        function handleKeyUp(e) {
            keysPressed.delete(e.code);
        }

        function handleTouchStart() {
            if (isTransitioning || activeScene !== 'title') return;
            clearTimeout(tapTimer);
            tapCount++;
            if (tapCount >= 7) {
                isTransitioning = true;
                transitionToSecretPage();
            } else {
                tapTimer = setTimeout(() => {
                    tapCount = 0;
                }, 500); 
            }
        }

        function transitionToSecretPage() {
            window.removeEventListener('keydown', handleKeyDown);
            window.removeEventListener('keyup', handleKeyUp);
            window.removeEventListener('touchstart', handleTouchStart);

            const riddleOverlay = document.getElementById('riddle-overlay');
            const canvasContainer = document.getElementById('liminal-canvas-container');
            const particleCanvasContainer = document.getElementById('particle-canvas-container');
            const animatedTextContainer = document.getElementById('animated-text-container');
            const socialLinksContainer = document.getElementById('social-links-container');
            
            gsap.killTweensOf(riddleOverlay);

            // Hollywood-level cinematic transition
            const cinematicTL = gsap.timeline();

            // Phase 1: Audio fade and particle dissolution
            if (audioInitialized) {
                Tone.Transport.stop();
                Tone.Transport.cancel();
                droneSynth.volume.rampTo(-Infinity, 2);
                padSynth.volume.rampTo(-Infinity, 2);
                cinematicLead.volume.rampTo(-Infinity, 2);
                arp.stop();
            }
            document.getElementById('mute-button').classList.remove('visible');

            // Phase 2: Dramatic particle implosion
            cinematicTL.to(particles.material.uniforms.uDisperse, {
                value: 15.0,
                duration: 1.5,
                ease: "power4.in"
            }, 0);

            // Phase 3: Screen blur and fade
            cinematicTL.to([riddleOverlay, canvasContainer], {
                duration: 2.0,
                opacity: 0,
                filter: "blur(20px)",
                scale: 1.1,
                ease: "power3.inOut"
            }, 0.5);

            // Phase 4: Camera zoom effect
            cinematicTL.to(camera.position, {
                z: FIELD_RADIUS * 0.3,
                duration: 2.0,
                ease: "power2.inOut"
            }, 0.5);

            // Phase 5: Scene cleanup and transition
            cinematicTL.call(() => {
                if (riddleOverlay) riddleOverlay.classList.remove('visible');
                if (canvasContainer) canvasContainer.classList.add('hidden');
                if (particles) {
                    particles.geometry.dispose();
                    particles.material.dispose();
                    scene.remove(particles);
                }
                if (renderer) {
                    renderer.renderLists.dispose();
                }

                activeScene = 'secret';
                startTextAnimation();

                // Phase 6: New scene emergence
                if (particleCanvasContainer) {
                    particleCanvasContainer.classList.remove('hidden');
                    particleCanvasContainer.style.filter = "blur(10px)";
                    particleCanvasContainer.style.opacity = "0";
                }
            }, null, 2.5);

            // Phase 7: New scene reveal with cinematic flair
            cinematicTL.to(particleCanvasContainer, {
                duration: 2.5,
                opacity: 1,
                filter: "blur(0px)",
                ease: "power3.out"
            }, 3.0);

            // Phase 8: UI elements cascade in
            cinematicTL.fromTo(animatedTextContainer, {
                opacity: 0,
                y: 50,
                scale: 0.9
            }, {
                opacity: 1,
                y: 0,
                scale: 1,
                duration: 1.5,
                ease: "back.out(1.7)"
            }, 4.0);

            cinematicTL.call(() => {
                if (animatedTextContainer) animatedTextContainer.classList.add('visible');
                if (socialLinksContainer) socialLinksContainer.classList.add('visible');
                
                const footerElements = document.getElementById('footer-elements');
                if (footerElements) footerElements.classList.add('visible');
            }, null, 4.0);

            // Phase 9: Social links and footer stagger in
            cinematicTL.fromTo("#social-links-container a", {
                opacity: 0,
                y: 30,
                scale: 0.8
            }, {
                opacity: 1,
                y: 0,
                scale: 1,
                duration: 0.8,
                stagger: 0.15,
                ease: "back.out(1.7)"
            }, 4.5);

            cinematicTL.fromTo(["#contact-link", "#rights-text"], {
                opacity: 0,
                y: 20
            }, {
                opacity: 1,
                y: 0,
                duration: 1.0,
                stagger: 0.2,
                ease: "power2.out"
            }, 5.0);
        }

        function handleTyping(e) {
            if (isTransitioning) return;
            const currentInput = e.target.value.toUpperCase();
            let matchCount = 0;
            const target = "LIMINAL";
            for(let i = 0; i < currentInput.length; i++) {
                if (i < target.length && currentInput[i] === target[i]) {
                    matchCount++;
                } else {
                    matchCount = 0;
                    break;
                }
            }
            const glowAmount = (matchCount / target.length) * 0.6;
            gsap.to(visualFeedback, { glow: glowAmount, duration: 0.5, ease: 'power2.out' });

            if (CORRECT_PASSWORDS.includes(currentInput)) {
                checkPassword(true);
            }
        }
        
        function checkPassword(isAutoTrigger = false) {
            if (isTransitioning) return;
            const passwordInput = document.getElementById('password-input');
            const passwordForm = document.getElementById('password-form');
            const enteredPassword = passwordInput.value.toUpperCase().trim();

            if (isAutoTrigger || CORRECT_PASSWORDS.includes(enteredPassword)) {
                isTransitioning = true; 
                passwordInput.blur();
                
                gsap.to(visualFeedback, { 
                    glow: 1.5, 
                    duration: 0.5, 
                    ease: 'power2.out'
                });

                transitionToSecretPage();
            } else {
                passwordForm.classList.add('error');
                passwordInput.value = '';
                setTimeout(() => passwordForm.classList.remove('error'), 500);

                gsap.to(visualFeedback, { 
                    disperse: 5.0, 
                    duration: 1.5,
                    ease: 'power2.out',
                    yoyo: true,
                    repeat: 1
                });
            }
        }
        
        function startTextAnimation() {
            const textElement = document.getElementById('animated-text');
            const flickerElement = document.getElementById('flicker-text');
            const dateLeftElement = document.getElementById('event-date-left');
            const dateRightElement = document.getElementById('event-date-right');
            if (!textElement || !flickerElement || !dateLeftElement || !dateRightElement) return;
            
            textElement.textContent = "SURFACE TENSION";

            const eventTitle = encodeURIComponent("SURFACE TENSION - DIGITAL DRIP AT SEXTANT");
            const eventLocation = encodeURIComponent("539 Valencia Street, San Francisco, CA");
            const eventDetails = encodeURIComponent(
                "Experience the intersection of digital art and specialty coffee.\n\nAn immersive art showcase from 5:00 PM to 6:30 PM, featuring exclusive digital installations and signature drinks crafted for the event.\n\nThe evening then transitions into a vibrant rave space with a live DJ set beginning at 7 PM. Expect exciting surprises and special gifts throughout the night.\n\n---\n\nFollow the journey:\nInstagram: https://www.instagram.com/surfacetension.co\nTikTok: https://www.tiktok.com/@surfacetension.co\nWebsite: https://www.surfacetension.co"
            );
            const calendarUrl = `https://www.google.com/calendar/render?action=TEMPLATE&text=${eventTitle}&dates=20250726T170000/20250726T220000&location=${eventLocation}&details=${eventDetails}`;
            
            dateLeftElement.innerHTML = `<a href="${calendarUrl}" target="_blank" rel="noopener noreferrer">JULY 26TH, 2025</a>`;
            dateRightElement.innerHTML = `<a href="${calendarUrl}" target="_blank" rel="noopener noreferrer">5:00PM</a>`;

            gsap.timeline({repeat: -1, repeatDelay: 2.5})
                .to(flickerElement, {
                    duration: 0.1,
                    opacity: 0.3,
                    textShadow: '0 0 20px #10b981, 0 0 40px #10b981'
                })
                .to(flickerElement, { duration: 0.05, opacity: 1 })
                .to(flickerElement, { duration: 0.05, opacity: 0.5, delay: 0.2 })
                .to(flickerElement, { duration: 0.05, opacity: 1 })
                .to(flickerElement, { duration: 0.1, opacity: 0.2, delay: 0.5 })
                .to(flickerElement, { duration: 0.2, opacity: 1, textShadow: '0 0 10px #10b981, 0 0 20px #10b981' });
        }
        
        // RESTORED ORIGINAL TIMING AND AUDIO - Removed problematic desktop monitoring
        function runOpeningSequence() {
            const riddleOverlay = document.getElementById('riddle-overlay');
            const tl = gsap.timeline();

            if (audioInitialized) {
                console.log('Starting audio sequence...');
                Tone.Transport.bpm.value = 110; 
                Tone.Transport.start();

                droneSynth.triggerAttack("C1", Tone.now());

                const audioStartTime = "1.5s";

                const chordProgression = [
                    { time: "0:0", note: "Cm", duration: "1m" },
                    { time: "1:0", note: "Gm", duration: "1m" },
                    { time: "2:0", note: "Fm", duration: "1m" },
                    { time: "3:0", note: "Cm", duration: "1m" },
                    { time: "4:0", note: "Fm", duration: "1.5m" }, 
                    { time: "5:2", note: "Cm", duration: "1.5m" }
                ];

                new Tone.Part((time, value) => {
                    let chord;
                    switch(value.note) {
                        case "Cm": chord = ["C3", "Eb3", "G3"]; arp.values = ["C2", "Eb2", "G2", "C3"]; break;
                        case "Gm": chord = ["G3", "Bb3", "D4"]; arp.values = ["G2", "Bb2", "D3", "G3"]; break;
                        case "Fm": chord = ["F3", "Ab3", "C4"]; arp.values = ["F2", "Ab2", "C3", "F3"]; break;
                    }
                    padSynth.triggerAttackRelease(chord, value.duration, time);
                }, chordProgression).start(audioStartTime);

                arp.start(audioStartTime);
                
                // Restored cinematic lead melody from original
                const cinematicMelodySequence = new Tone.Sequence((time, note) => {
                    if (note) {
                        cinematicLead.triggerAttackRelease(note, '2n', time);
                        
                        if (cinematicLead.voice0 && cinematicLead.voice0.filter) {
                            cinematicLead.voice0.filter.frequency.setValueAtTime(800, time);
                            cinematicLead.voice0.filter.frequency.exponentialRampToValueAtTime(2400, time + 1.5);
                        }
                        if (cinematicLead.voice1 && cinematicLead.voice1.filter) {
                            cinematicLead.voice1.filter.frequency.setValueAtTime(600, time);
                            cinematicLead.voice1.filter.frequency.exponentialRampToValueAtTime(1800, time + 1.5);
                        }
                    }
                }, [
                    null, null, 'C4', null, 
                    'Eb4', null, 'G4', null,
                    'Bb4', null, 'G4', 'F4',
                    'Eb4', null, 'C4', null,
                    null, 'G4', 'F4', 'Eb4',
                    'D4', null, 'C4', null
                ], '2n').start("6.5s");

                cinematicMelodySequence.humanize = true;
                cinematicMelodySequence.probability = 0.85;

                padSynth.volume.rampTo(-18, 0.1, audioStartTime);
                if (padFilter) {
                    padFilter.frequency.rampTo(4000, 7, Tone.now() + 2.0); 
                }
            }

            // ORIGINAL TIMING PRESERVED
            tl.to(particles.material.uniforms.uExpansionProgress, {
                value: 1.0,
                duration: 6,
                ease: 'power3.out'
            }, "start");
            
            tl.to(particles.material.uniforms.uConvergenceProgress, {
                value: 1.0,
                duration: 8.5,
                ease: 'power2.inOut',
                onStart: () => {
                    if (audioInitialized) {
                         climaxChime.triggerAttack(Tone.now() + 0.1);
                    }
                }
            }, "start+=4.0");

            tl.to(particles.material.uniforms.uDisintegrationProgress, {
                value: 1.0,
                duration: 3.5, 
                ease: 'power2.in',
                onStart: () => {
                    if (audioInitialized) {
                        disintegrateNoise.triggerAttack(Tone.now() + 0.1);
                    }
                }
            }, "start+=13.5");

            tl.to(riddleOverlay, {
                opacity: 1,
                duration: 1.5,
                ease: 'power2.out',
                onStart: () => {
                    if (riddleOverlay) riddleOverlay.classList.add('visible');
                    if(audioInitialized) {
                        const outroTime = Tone.Transport.now() + 35; 
                        padSynth.volume.rampTo(-Infinity, 4, outroTime);
                        cinematicLead.volume.rampTo(-Infinity, 5, outroTime);
                        arp.stop(outroTime + 3);
                        droneSynth.volume.rampTo(-Infinity, 6, outroTime + 0.5);
                        
                        Tone.Transport.stop(outroTime + 8);
                    }
                }
            }, ">-1.0");
        }
        
        function onWindowResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            composer.setSize(width, height);

            if(particleCamera) {
                particleCamera.aspect = width / height;
                particleCamera.updateProjectionMatrix();
            }
            if(particleRenderer) {
                particleRenderer.setSize(width, height);
            }
            if(particleComposer) {
                particleComposer.setSize(width, height);
            }
            
            if (sextantCubeCamera) {
                const sextantCanvas = document.getElementById('sextant-cube-canvas');
                if (sextantCanvas) {
                    const size = 40;
                    sextantCubeCamera.aspect = 1;
                    sextantCubeCamera.updateProjectionMatrix();
                    if(sextantCubeRenderer) {
                        sextantCubeRenderer.setSize(size, size);
                    }
                }
            }
        }

        // Animation with finale background effects
        let lastTimeUpdate = 0;
        const TIME_UPDATE_INTERVAL = 16;

        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();
            const now = performance.now();
            
            if (activeScene === 'title' && particles) {
                if (now - lastTimeUpdate > TIME_UPDATE_INTERVAL) {
                    particles.material.uniforms.uTime.value = elapsedTime;
                    lastTimeUpdate = now;
                }
                particles.material.uniforms.uDisperse.value = visualFeedback.disperse;
                if (bloomPass) {
                    bloomPass.strength = 0.6 + visualFeedback.glow;
                }
                composer.render();
            } else if (activeScene === 'secret') {
                if (backgroundVisual) {
                    backgroundVisual.material.uniforms.uTime.value = elapsedTime;
                    // Enhanced Hollywood-level finale animation with more sophisticated 3D effects
                    backgroundVisual.rotation.z += 3e-5;
                    backgroundVisual.rotation.x += 1e-5;
                    backgroundVisual.rotation.y += 2e-5;
                    
                    // Advanced ripple animation with depth and layering
                    const positions = backgroundVisual.geometry.attributes.position.array;
                    for (let i = 0; i < positions.length; i += 3) {
                        const x = positions[i];
                        const y = positions[i + 1];
                        const d = Math.sqrt(x * x + y * y);
                        
                        // Multi-layered wave system for blockbuster effect
                        const wave1 = Math.sin(d * 1.2 - elapsedTime * 0.15) * 1.5 * Math.exp(-d * 0.1);
                        const wave2 = Math.sin(d * 2.5 - elapsedTime * 0.25) * 0.8 * Math.exp(-d * 0.15);
                        const wave3 = Math.sin(d * 0.8 - elapsedTime * 0.1) * 2.2 * Math.exp(-d * 0.08);
                        
                        // Cinematic depth variation
                        const depthFactor = Math.sin(elapsedTime * 0.05 + d * 0.1) * 0.3;
                        
                        // Enhanced ripple with multiple wave interference
                        positions[i + 2] = wave1 + wave2 * 0.6 + wave3 * 0.4 + depthFactor;
                    }
                    backgroundVisual.geometry.attributes.position.needsUpdate = true;
                }
                if (particleCamera) {
                    // Enhanced camera movement for cinematic feel
                    particleCamera.position.z = 2 + Math.sin(elapsedTime * 0.1) * 0.2;
                    particleCamera.position.x = Math.sin(elapsedTime * 0.06) * 0.1;
                    particleCamera.position.y = Math.cos(elapsedTime * 0.08) * 0.08;
                }
                particleComposer.render();
            }

            if (sextantCube && activeScene === 'secret') {
                sextantCube.rotation.x += 0.01;
                sextantCube.rotation.y += 0.015;
                sextantCube.rotation.z += 0.005;
                sextantCubeRenderer.render(sextantCubeScene, sextantCubeCamera);
            }
        }

        init();
    });

    function copyCode(event) {
        event.preventDefault(); 
        event.stopPropagation();

        const code = document.getElementById('access-code-text').innerText;
        
        try {
            const textArea = document.createElement("textarea");
            textArea.value = code;
            textArea.style.position = "fixed"; 
            textArea.style.top = "0";
            textArea.style.left = "0";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);

            const notification = document.getElementById('copy-notification');
            notification.classList.add('show');
            setTimeout(() => {
                notification.classList.remove('show');
            }, 2000);
        } catch (err) {
            console.error('Fallback: Oops, unable to copy', err);
        }
    }
    </script>
</body>
</html>
