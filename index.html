<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Surface Tension</title>
    
    <!-- FAVICON: Custom SVG favicon for the brand -->
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cpath d='M20 25 C20 15, 30 15, 40 25 L60 75 C70 85, 80 85, 80 75' stroke='%23FFFFFF' stroke-width='10' fill='none' stroke-linecap='round' stroke-linejoin='round'/%3E%3Cpath d='M45 50 L75 50' stroke='%23FFFFFF' stroke-width='10' fill='none' stroke-linecap='round'/%3E%3C/svg%3E">

    <!-- Preconnect for faster font loading -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://use.typekit.net" crossorigin>
    
    <!-- Fonts -->
    <link rel="stylesheet" href="https://use.typekit.net/jhs3mli.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&display=swap" rel="stylesheet">

    <!-- Analytics -->
    <script>
        window.va = window.va || function () { (window.va.q = window.va.q || []).push(arguments); };
    </script>
    <script src="/_vercel/insights/script.js" defer></script>
    <!-- Google Analytics - Replace GA_MEASUREMENT_ID with your own ID -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=GA_MEASUREMENT_ID"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'GA_MEASUREMENT_ID');
    </script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            background-color: #000000; /* Pure black for maximum contrast */
            color: white;
            font-family: 'Inter', sans-serif;
            /* UX Refinement: Disable text selection for a cleaner experience */
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        /* --- Optimization: Smooth Fade-in --- */
        .content-hidden {
            opacity: 0;
        }
        .content-visible {
            opacity: 1;
            transition: opacity 1.5s ease-in;
        }

        #vfx-canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #text-container {
            position: absolute;
            inset: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3;
            pointer-events: none;
        }

        h1 {
            font-family: "ivypresto-display", serif;
            font-weight: 300;
            font-style: normal;
            font-size: clamp(3rem, 12vw, 10rem);
            color: rgba(255, 255, 255, 0.9);
            text-align: center;
            letter-spacing: 0.05em;
            text-shadow: 0 0 50px rgba(0, 0, 0, 0.9);
        }

        /* --- UI Elements --- */
        #ui-container {
            position: fixed;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            z-index: 100;
            transition: opacity 0.5s ease-in-out;
        }

        #ui-container.ui-hidden {
            opacity: 0;
            pointer-events: none;
        }

        #audio-button {
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.7);
            font-family: 'Inter', sans-serif;
            font-size: 0.8rem;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        #audio-button:hover {
            background-color: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
        }
        #audio-button.active {
            background-color: #10b981;
            color: white;
            border-color: #10b981;
        }

        #social-links-container {
            display: flex;
            gap: 2.5rem;
            align-items: center;
            justify-content: center;
            padding-bottom: 2rem;
            transition: transform 0.5s ease-in-out;
        }

        #ui-container.audio-active #social-links-container {
            transform: scale(0.9);
        }

        #social-links-container a {
            color: rgba(255, 255, 255, 0.4);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            padding: 12px;
            pointer-events: auto;
            will-change: transform;
        }
        #social-links-container a::before {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 8px;
            background: linear-gradient(45deg, 
                rgba(16, 185, 129, 0.1), 
                rgba(168, 85, 247, 0.1), 
                rgba(0, 255, 255, 0.1)
            );
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: -1;
        }
        #social-links-container a:hover {
            transform: translateY(-3px) scale(1.08);
        }
        #social-links-container a:hover::before {
            opacity: 1;
            transform: scale(1);
        }
        #social-links-container a:nth-child(1):hover { color: #E4405F; }
        #social-links-container a:nth-child(2):hover { color: #1DA1F2; }
        #social-links-container a:nth-child(3):hover { color: #00f2ea; }
        #social-links-container a:nth-child(4):hover { color: #1877F2; }
        #social-links-container svg {
            width: 18px;
            height: 18px;
            stroke-width: 1.5;
            filter: drop-shadow(0 2px 8px rgba(0,0,0,0.4));
        }

        #footer-elements {
            position: fixed;
            bottom: 0.5rem;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 2rem;
            z-index: 99;
            font-family: 'Inter', sans-serif;
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.4);
            pointer-events: none;
        }
        
        #contact-link {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: rgba(255, 255, 255, 0.5);
            text-decoration: none;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            pointer-events: auto;
        }
        #contact-link:hover {
            color: #10b981;
            transform: translateY(-1px);
        }
        #contact-link svg { width: 14px; height: 14px; }
        #rights-text { text-transform: uppercase; letter-spacing: 0.05em; }

        @media (max-width: 768px) {
            #social-links-container { 
                gap: 1.5rem;
                padding-bottom: 2rem;
            }
             #footer-elements { 
                flex-direction: column; 
                gap: 0.5rem; 
                padding: 0 1rem; 
                bottom: 0.3rem; 
            }
        }
    </style>
</head>
<body>
    <div id="vfx-canvas-container" class="content-hidden"></div>
    <div id="text-container" class="content-hidden">
        <h1>SURFACE TENSION</h1>
    </div>

    <div id="ui-container" class="content-hidden">
        <button id="audio-button">Enable Audio</button>
        <div id="social-links-container">
            <a href="https://www.instagram.com/surfacetension.co" target="_blank" rel="noopener noreferrer" aria-label="Instagram"><svg fill="currentColor" viewBox="0 0 24 24"><path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.85s-.011 3.584-.069 4.85c-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07s-3.584-.012-4.85-.07c-3.252-.148-4.771-1.691-4.919-4.919-.058-1.265-.07-1.645-.07-4.85s.012-3.584.07-4.85c.148-3.225 1.664-4.771 4.919-4.919C8.416 2.175 8.796 2.163 12 2.163zm0 1.802c-3.143 0-3.505.012-4.73.068-2.693.123-3.995 1.424-4.118 4.118-.056 1.225-.068 1.586-.068 4.73s.012 3.505.068 4.73c.123 2.693 1.424 3.995 4.118 4.118 1.225.056 1.586.068 4.73.068s3.505-.012 4.73-.068c2.693-.123 3.995-1.424 4.118-4.118.056-1.225.068-1.586.068-4.73s-.012-3.505-.068-4.73c-.123-2.693-1.424-3.995-4.118-4.118-1.225-.056-1.586-.068-4.73-.068zm0 3.888c-2.402 0-4.35 1.948-4.35 4.35s1.948 4.35 4.35 4.35 4.35-1.948 4.35-4.35-1.948-4.35-4.35-4.35zm0 7.167c-1.553 0-2.817-1.264-2.817-2.817s1.264-2.817 2.817-2.817 2.817 1.264 2.817 2.817-1.264 2.817-2.817 2.817zm4.965-7.332c-.608 0-1.1.492-1.1 1.1s.492 1.1 1.1 1.1 1.1-.492 1.1-1.1-.492-1.1-1.1-1.1z"></path></svg></a>
            <a href="https://www.twitter.com/surfacetensi_n" target="_blank" rel="noopener noreferrer" aria-label="Twitter"><svg fill="currentColor" viewBox="0 0 24 24"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"></path></svg></a>
            <a href="https://www.tiktok.com/@surfacetension.co" target="_blank" rel="noopener noreferrer" aria-label="TikTok"><svg fill="currentColor" viewBox="0 0 24 24"><path d="M19.59 6.69a4.83 4.83 0 0 1-3.77-4.25V2h-3.45v13.67a2.89 2.89 0 0 1-5.2 1.74 2.89 2.89 0 0 1 2.31-4.64 2.93 2.93 0 0 1 .88.13V9.4a6.84 6.84 0 0 0-1-.05A6.33 6.33 0 0 0 5 20.1a6.34 6.34 0 0 0 10.86-4.43v-7a8.16 8.16 0 0 0 4.77 1.52v-3.4a4.85 4.85 0 0 1-1-.1z"/></svg></a>
            <a href="https://www.facebook.com/profile.php?id=61577915426183" target="_blank" rel="noopener noreferrer" aria-label="Facebook"><svg fill="currentColor" viewBox="0 0 24 24"><path d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z"/></svg></a>
        </div>
    </div>

    <div id="footer-elements" class="content-hidden">
        <a id="contact-link" href="mailto:help.surfacetension@gmail.com"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 8l7.89 4.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"></path></svg>Contact Us</a>
        <div id="rights-text">All Rights Reserved</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js" defer></script>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const CinematicEngine = {
            scenes: {},
            renderers: [],
            audio: {
                analyser: null,
                dataArray: null,
                lastDataArray: null,
                smoothedEnergy: 0,
                smoothedTone: 0.5,
                // --- ADVANCED ANALYSIS ---
                archetype: 0.5, // 0: Organic/Vocal, 1: Electronic/Percussive
                archetypeHistory: new Array(100).fill(0.5),
                vocalClarity: 0, // 0: Noisy/Complex, 1: Clear Tonal/Vocal
                vocalClarityHistory: new Array(50).fill(0),
                flux: { bass: 0, mid: 0, high: 0 },
                smoothedFlux: { bass: 0, mid: 0, high: 0 },
                energyHistory: new Array(128).fill(0),
                dropThreshold: 1.5,
                lastDropTime: 0,
                silenceCounter: 0,
                silenceThreshold: 150,
            },
            color: {
                currentPalette: {},
                lastTone: 0.5,
                // --- IMPROVED: More frequent color changes ---
                toneChangeThreshold: 0.035, // Lowered for more sensitivity
                paletteChangeInterval: 20000, // 20 seconds
                lastAudioPaletteChange: 0,
            },

            getSimplexNoiseShader() {
                return `
                    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                    vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
                    float snoise(vec3 v) {
                      const vec2 C = vec2(1.0/6.0, 1.0/3.0); const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                      vec3 i = floor(v + dot(v, C.yyy)); vec3 x0 = v - i + dot(i, C.xxx);
                      vec3 g = step(x0.yzx, x0.xyz); vec3 l = 1.0 - g; vec3 i1 = min(g, l.zxy); vec3 i2 = max(g, l.zxy);
                      vec3 x1 = x0 - i1 + C.xxx; vec3 x2 = x0 - i2 + C.yyy; vec3 x3 = x0 - D.yyy;
                      i = mod289(i);
                      vec4 p = permute( permute( permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                      float n_ = 0.142857142857; vec3 ns = n_ * D.wyz - D.xzx;
                      vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                      vec4 x_ = floor(j * ns.z); vec4 y_ = floor(j - 7.0 * x_);
                      vec4 x = x_ *ns.x + ns.yyyy; vec4 y = y_ *ns.x + ns.yyyy;
                      vec4 h = 1.0 - abs(x) - abs(y); vec4 b0 = vec4(x.xy, y.xy); vec4 b1 = vec4(x.zw, y.zw);
                      vec4 s0 = floor(b0)*2.0 + 1.0; vec4 s1 = floor(b1)*2.0 + 1.0; vec4 sh = -step(h, vec4(0.0));
                      vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy; vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
                      vec3 p0 = vec3(a0.xy,h.x); vec3 p1 = vec3(a0.zw,h.y); vec3 p2 = vec3(a1.xy,h.z); vec3 p3 = vec3(a1.zw,h.w);
                      vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                      p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                      vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                      m = m * m; return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
                    }
                `;
            },

            initAudio() {
                const audioButton = document.getElementById('audio-button');
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    audioButton.textContent = "Audio API not supported";
                    return;
                }

                audioButton.addEventListener('click', async () => {
                    if (this.audio.analyser) return;

                    try {
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                        const source = audioContext.createMediaStreamSource(stream);
                        this.audio.analyser = audioContext.createAnalyser();
                        this.audio.analyser.fftSize = 1024;
                        this.audio.analyser.smoothingTimeConstant = 0.8;
                        source.connect(this.audio.analyser);
                        
                        const bufferLength = this.audio.analyser.frequencyBinCount;
                        this.audio.dataArray = new Uint8Array(bufferLength);
                        this.audio.lastDataArray = new Uint8Array(bufferLength);

                        audioButton.textContent = "Audio Enabled";
                        audioButton.classList.add('active');
                        
                        const uiContainer = document.getElementById('ui-container');
                        uiContainer.classList.add('audio-active');
                        setTimeout(() => uiContainer.classList.add('ui-hidden'), 2000);

                    } catch (err) {
                        console.error("Error accessing microphone:", err);
                        audioButton.textContent = "Audio Denied";
                    }
                });
            },

            createScene(id, options) {
                const container = document.getElementById(id);
                if (!container) return;

                try {
                    const scene = new THREE.Scene();
                    const camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
                    camera.position.z = options.cameraZ || 5;

                    const renderer = new THREE.WebGLRenderer({
                        antialias: true,
                        alpha: true,
                        powerPreference: "high-performance"
                    });
                    renderer.setClearColor(0x000000, 0); 
                    renderer.setSize(container.clientWidth, container.clientHeight);
                    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
                    container.appendChild(renderer.domElement);
                    this.renderers.push(renderer);
                    
                    const material = new THREE.ShaderMaterial(options.shader);
                    const mesh = new THREE.Mesh(options.geometry, material);
                    scene.add(mesh);

                    const clock = new THREE.Clock();
                    
                    const animate = () => {
                        requestAnimationFrame(animate);
                        const t = clock.getElapsedTime();
                        
                        if (options.update) {
                            options.update({ t, main: mesh });
                        }
                        
                        renderer.render(scene, camera);
                    };
                    animate();

                    this.scenes[id] = { scene, camera, renderer, mesh };

                } catch (e) {
                    console.error(`Error creating VFX scene "${id}":`, e);
                    throw e;
                }
            },
            
            initCinematicAtmosphere() {
                const geometry = new THREE.PlaneGeometry(20, 12, 1, 1);

                const generatePaletteFromTone = (tone) => {
                    const baseHue = 0.6 - (tone * 0.6); 
                    const palette = {
                        color1: new THREE.Color().setHSL(baseHue, 0.6, 0.1),
                        color2: new THREE.Color().setHSL((baseHue + 0.1) % 1.0, 0.7, 0.4),
                        color3: new THREE.Color().setHSL((baseHue + 0.5) % 1.0, 0.8, 0.6)
                    };
                    return palette;
                };
                
                const transitionToPalette = (mesh, newPalette) => {
                    const duration = 12; 
                    gsap.to(mesh.material.uniforms.uColor1.value, { r: newPalette.color1.r, g: newPalette.color1.g, b: newPalette.color1.b, duration: duration, ease: "sine.inOut" });
                    gsap.to(mesh.material.uniforms.uColor2.value, { r: newPalette.color2.r, g: newPalette.color2.g, b: newPalette.color2.b, duration: duration, ease: "sine.inOut" });
                    gsap.to(mesh.material.uniforms.uColor3.value, { r: newPalette.color3.r, g: newPalette.color3.g, b: newPalette.color3.b, duration: duration, ease: "sine.inOut" });
                    this.color.currentPalette = newPalette;
                };

                this.color.currentPalette = generatePaletteFromTone(0.5);
                this.color.lastAudioPaletteChange = performance.now();

                this.createScene('vfx-canvas-container', {
                    cameraZ: 5,
                    geometry: geometry,
                    shader: {
                        uniforms: { 
                            uTime: { value: 0 }, 
                            uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                            uAudioEnergy: { value: 0.0 },
                            uDropIntensity: { value: 0.0 },
                            uTone: { value: 0.5 },
                            uNoiseSeed: { value: Math.random() * 1000 },
                            uColor1: { value: this.color.currentPalette.color1 },
                            uColor2: { value: this.color.currentPalette.color2 },
                            uColor3: { value: this.color.currentPalette.color3 },
                            uKick: { value: 0.0 },
                            uSnare: { value: 0.0 },
                            uHiHat: { value: 0.0 },
                            // --- NEW UNIFORMS ---
                            uArchetype: { value: 0.5 },
                            uVocalClarity: { value: 0.0 },
                        },
                        vertexShader: `
                            varying vec2 vUv;
                            void main() {
                                vUv = uv;
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }`,
                        fragmentShader: `
                            precision highp float; 
                            ${this.getSimplexNoiseShader()}

                            varying vec2 vUv;
                            uniform float uTime;
                            uniform float uAudioEnergy;
                            uniform float uDropIntensity;
                            uniform float uTone;
                            uniform float uNoiseSeed;
                            uniform vec3 uColor1;
                            uniform vec3 uColor2;
                            uniform vec3 uColor3;
                            uniform float uKick;
                            uniform float uSnare;
                            uniform float uHiHat;
                            // --- NEW UNIFORMS ---
                            uniform float uArchetype;
                            uniform float uVocalClarity;

                            vec3 hsv2rgb(vec3 c) {
                                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
                            }

                            // --- IMPROVED: More advanced FBM for richer textures ---
                            float fbm(vec3 p) {
                                float f = 0.0;
                                mat3 m = mat3(0.00, 0.80, 0.60, -0.80, 0.36, -0.48, -0.60, -0.48, 0.64);
                                f += 0.5000 * snoise(p); p = m * p * 2.02;
                                f += 0.2500 * snoise(p); p = m * p * 2.03;
                                f += 0.1250 * snoise(p); p = m * p * 2.01;
                                f += 0.0625 * snoise(p);
                                return f / 0.9375;
                            }
                            
                            // --- NEW: Domain Warping function for fluid, non-repetitive motion ---
                            vec2 domainWarp(vec2 uv, float time, float warpAmount) {
                                vec3 p = vec3(uv * 2.0, time * 0.1);
                                float warpX = fbm(p) * warpAmount;
                                float warpY = fbm(p + vec3(1.0, 2.0, 0.0)) * warpAmount;
                                return vec2(warpX, warpY);
                            }

                            void main() {
                                vec2 uv = vUv;
                                vec2 centeredUv = uv - 0.5;
                                float t = uTime;

                                // --- Supernova Drop Effect ---
                                float warpFactor = uDropIntensity * 0.1;
                                vec2 warpUv = centeredUv * (1.0 + warpFactor) + 0.5;
                                
                                // --- DYNAMIC MOTION ---
                                // The base speed of the visual evolution
                                float baseSpeed = t * 0.05 + t * uAudioEnergy * 0.1;
                                // The amount of fluid distortion, increases with energy, but calms with vocal clarity
                                float warpAmount = (0.3 + uAudioEnergy * 0.5) * (1.0 - uVocalClarity * 0.5);
                                
                                // --- IMPROVED: Apply Domain Warping for complex motion ---
                                vec2 warpedUv = warpUv + domainWarp(warpUv, t, warpAmount);

                                // --- VISUAL SHAPE & TEXTURE ---
                                // Base pattern with multiple layers for depth
                                float pattern = fbm(vec3(warpedUv * 2.0 + uNoiseSeed, baseSpeed));
                                
                                // Detail layer, more prominent in electronic music (high archetype)
                                float detailPattern = fbm(vec3(warpedUv * 8.0, baseSpeed * 2.0));
                                
                                // Combine patterns. High vocal clarity softens the details.
                                float finalPattern = mix(pattern, pattern + detailPattern * 0.3, uArchetype * (1.0 - uVocalClarity * 0.7));

                                // --- VOCAL & BEAT REACTIONS ---
                                // A soft, central glow for vocals/tonal sounds
                                float vocalBloom = smoothstep(0.0, 0.8, 1.0 - length(centeredUv)) * uVocalClarity * 0.4;
                                
                                // Beat ripples, now more pronounced
                                float kickRipple = 1.0 - smoothstep(0.0, 0.6, length(centeredUv)) * uKick * 1.2;
                                float snareRipple = 1.0 - smoothstep(0.1, 0.3, length(centeredUv)) * uSnare * 0.8;
                                finalPattern *= kickRipple * snareRipple;

                                // --- COLORING ---
                                vec3 color = mix(uColor1, uColor2, smoothstep(-0.2, 0.2, finalPattern));
                                color = mix(color, uColor3, smoothstep(0.4, 0.6, detailPattern));
                                color += vocalBloom * uColor3;

                                // --- FINAL COMPOSITION ---
                                float vignette = 1.0 - length(centeredUv * 1.0);
                                float finalIntensity = 0.6 + uAudioEnergy * 1.2 + uDropIntensity * 2.0;
                                vec3 finalColor = color * vignette * finalIntensity;
                                
                                // Iridescent glow on drops, now more vibrant
                                float rainbowDist = length(centeredUv + snoise(vec3(uv * 2.0, t * 0.1)) * 0.1 * uDropIntensity);
                                vec3 rainbowColor = hsv2rgb(vec3(rainbowDist * 2.0 - t * 0.2, 0.8, 1.0));
                                finalColor += uDropIntensity * rainbowColor * (1.0 - smoothstep(0.0, 0.5, rainbowDist)) * 0.8;

                                // Hi-hat sparkles, more noticeable in electronic music
                                finalColor += snoise(vec3(uv * 200.0, t * 10.0)) * uHiHat * uArchetype * 0.7;

                                // A subtle grain to finish the image
                                finalColor += (snoise(vec3(uv * 800.0, t * 2.0)) * 0.5 + 0.5) * 0.02;
                                
                                gl_FragColor = vec4(finalColor, 1.0);
                            }`
                    },
                    update: ({ t, main }) => {
                        const pNow = performance.now();
                        
                        if (this.audio.analyser) {
                            this.audio.analyser.getByteFrequencyData(this.audio.dataArray);
                            const bufferLength = this.audio.analyser.frequencyBinCount;
                            
                            let energy = 0;
                            let spectralCentroid = 0, spectralSum = 0;
                            const bassBins = Math.floor(bufferLength * 0.1);
                            const midBins = Math.floor(bufferLength * 0.6);
                            
                            // --- ADVANCED: Timbre and Vocal analysis variables ---
                            let geometricMean = 0, arithmeticMean = 0, peakValue = 0;
                            let vocalEnergy = 0, totalVocalWeight = 0, vocalCentroid = 0;

                            this.audio.flux = { bass: 0, mid: 0, high: 0 };
                            for (let i = 0; i < bufferLength; i++) {
                                const currentVal = this.audio.dataArray[i];
                                const lastVal = this.audio.lastDataArray[i];
                                const flux = Math.max(0, currentVal - lastVal);
                                if (i < bassBins) this.audio.flux.bass += flux;
                                else if (i < midBins) this.audio.flux.mid += flux;
                                else this.audio.flux.high += flux;

                                const val = Math.pow(currentVal / 255, 2);
                                energy += val;
                                spectralCentroid += i * val;
                                spectralSum += val;

                                // --- Timbre analysis calculations ---
                                if(currentVal > 0) geometricMean += Math.log(currentVal);
                                arithmeticMean += currentVal;
                                if(currentVal > peakValue) peakValue = currentVal;
                                
                                // --- Vocal clarity analysis ---
                                if (i > bassBins && i < midBins) {
                                    vocalEnergy += currentVal;
                                    vocalCentroid += i * currentVal;
                                }
                            }
                            this.audio.lastDataArray.set(this.audio.dataArray);
                            
                            energy = Math.sqrt(energy / bufferLength);
                            if (spectralSum > 0) spectralCentroid /= spectralSum;

                            // --- Finalize timbre metrics ---
                            arithmeticMean /= bufferLength;
                            geometricMean = Math.exp(geometricMean / bufferLength);
                            const spectralFlatness = arithmeticMean > 0 ? geometricMean / arithmeticMean : 0;
                            
                            // --- Finalize vocal clarity ---
                            if(vocalEnergy > 0) vocalCentroid /= vocalEnergy;
                            const vocalFocus = 1.0 - Math.abs(vocalCentroid - (bassBins + (midBins - bassBins) / 2)) / ((midBins - bassBins) / 2);
                            this.audio.vocalClarityHistory.push(vocalFocus * (1.0 - spectralFlatness));
                            this.audio.vocalClarityHistory.shift();
                            const avgVocalClarity = this.audio.vocalClarityHistory.reduce((a, b) => a + b, 0) / this.audio.vocalClarityHistory.length;
                            this.audio.vocalClarity = this.audio.vocalClarity * 0.95 + avgVocalClarity * 0.05;

                            // --- Update Archetype (Genre Guess) ---
                            const rawArchetype = Math.min(1.0, (1.0 - spectralFlatness) * 1.5);
                            this.audio.archetypeHistory.push(rawArchetype);
                            this.audio.archetypeHistory.shift();
                            const avgArchetype = this.audio.archetypeHistory.reduce((a, b) => a + b, 0) / this.audio.archetypeHistory.length;
                            this.audio.archetype = this.audio.archetype * 0.98 + avgArchetype * 0.02;

                            if (energy < 0.005) { this.audio.silenceCounter++; } else { this.audio.silenceCounter = 0; }
                            if (this.audio.silenceCounter > this.audio.silenceThreshold) {
                                main.material.uniforms.uNoiseSeed.value = Math.random() * 1000;
                                this.audio.silenceCounter = 0;
                            }
                            
                            this.audio.smoothedEnergy = Math.max(energy, this.audio.smoothedEnergy * 0.98);
                            this.audio.smoothedTone = (spectralCentroid / bufferLength) * 0.05 + this.audio.smoothedTone * 0.95;
                            
                            this.audio.smoothedFlux.bass = Math.max(this.audio.flux.bass / (bassBins * 255), this.audio.smoothedFlux.bass * 0.92);
                            this.audio.smoothedFlux.mid = Math.max(this.audio.flux.mid / ((midBins - bassBins) * 255), this.audio.smoothedFlux.mid * 0.90);
                            this.audio.smoothedFlux.high = Math.max(this.audio.flux.high / ((bufferLength - midBins) * 255), this.audio.smoothedFlux.high * 0.88);

                            this.audio.energyHistory.push(this.audio.smoothedEnergy);
                            this.audio.energyHistory.shift();
                            const avgEnergy = this.audio.energyHistory.reduce((a, b) => a + b, 0) / this.audio.energyHistory.length;
                            if (this.audio.smoothedEnergy > avgEnergy * this.audio.dropThreshold && t > this.audio.lastDropTime + 2.0) {
                                main.material.uniforms.uDropIntensity.value = 1.0;
                                this.audio.lastDropTime = t;
                            }
                            main.material.uniforms.uDropIntensity.value *= 0.96;
                            
                            // --- Update Shader Uniforms ---
                            main.material.uniforms.uAudioEnergy.value = this.audio.smoothedEnergy;
                            main.material.uniforms.uTone.value = this.audio.smoothedTone;
                            main.material.uniforms.uKick.value = this.audio.smoothedFlux.bass;
                            main.material.uniforms.uSnare.value = this.audio.smoothedFlux.mid;
                            main.material.uniforms.uHiHat.value = this.audio.smoothedFlux.high;
                            main.material.uniforms.uArchetype.value = this.audio.archetype;
                            main.material.uniforms.uVocalClarity.value = this.audio.vocalClarity;

                            // --- IMPROVED: More frequent color changes ---
                            if (Math.abs(this.audio.smoothedTone - this.color.lastTone) > this.color.toneChangeThreshold || pNow - this.color.lastAudioPaletteChange > this.color.paletteChangeInterval) {
                                const newPalette = generatePaletteFromTone(this.audio.smoothedTone);
                                transitionToPalette(main, newPalette);
                                this.color.lastTone = this.audio.smoothedTone;
                                this.color.lastAudioPaletteChange = pNow;
                            }
                        } else {
                            // Non-Audio Mode
                             if (pNow - this.color.lastAudioPaletteChange > this.color.paletteChangeInterval) {
                                const newPalette = generatePaletteFromTone(Math.random());
                                transitionToPalette(main, newPalette);
                                this.color.lastAudioPaletteChange = pNow;
                            }
                        }

                        main.material.uniforms.uTime.value = t;
                    }
                });
            },
            
            handleResize() {
                this.renderers.forEach((renderer) => {
                    const container = renderer.domElement.parentElement;
                    if (container && container.clientWidth > 0) {
                        const sceneData = Object.values(this.scenes)[0];
                        if (sceneData && sceneData.camera) {
                            sceneData.camera.aspect = container.clientWidth / container.clientHeight;
                            sceneData.camera.updateProjectionMatrix();
                            if (sceneData.mesh.material.uniforms.uResolution) {
                               sceneData.mesh.material.uniforms.uResolution.value.set(container.clientWidth, container.clientHeight);
                            }
                        }
                        renderer.setSize(container.clientWidth, container.clientHeight);
                    }
                });
            }
        };

        try {
            if (!window.THREE) {
                throw new Error("Three.js library failed to load.");
            }
            CinematicEngine.initAudio();
            CinematicEngine.initCinematicAtmosphere();
            window.addEventListener('resize', () => CinematicEngine.handleResize());

            document.querySelectorAll('.content-hidden').forEach(el => {
                el.classList.add('content-visible');
                el.classList.remove('content-hidden');
            });
            
            const uiContainer = document.getElementById('ui-container');
            let uiHideTimeout;
            const showUi = () => {
                uiContainer.classList.remove('ui-hidden');
                clearTimeout(uiHideTimeout);
                if (uiContainer.classList.contains('audio-active')) {
                    uiHideTimeout = setTimeout(() => uiContainer.classList.add('ui-hidden'), 2500);
                }
            };
            window.addEventListener('mousemove', showUi);
            window.addEventListener('dblclick', showUi);
            
            let touchStartTime = 0;
            window.addEventListener('touchstart', () => { touchStartTime = Date.now(); });
            window.addEventListener('touchend', () => {
                if (Date.now() - touchStartTime > 500) showUi(); // Long press
            });


        } catch (error) {
            console.error("A fatal error occurred during page initialization:", error);
            const errorContainer = document.getElementById('vfx-canvas-container') || document.body;
            errorContainer.innerHTML = `
                <div style="padding: 2em; text-align: center; color: white; font-family: monospace; z-index: 1000; position: relative;">
                    <h2 style="color: #ff6b6b;">An Error Occurred</h2>
                    <p style="margin-top: 1em;">The background animation could not be started. Please check the browser console (F12) for more details.</p>
                    <pre style="text-align: left; display: inline-block; margin-top: 1.5em; padding: 1em; background: rgba(0,0,0,0.3); border: 1px solid #555; border-radius: 5px; max-width: 90%; overflow-wrap: break-word; white-space: pre-wrap;">${error.stack || error.message}</pre>
                </div>`;
            document.getElementById('ui-container').style.display = 'none';
        }
    });
    </script>
</body>
</html>
